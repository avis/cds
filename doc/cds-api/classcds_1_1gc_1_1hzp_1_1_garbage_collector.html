<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>cds: cds::gc::hzp::GarbageCollector Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">cds
   &#160;<span id="projectnumber">1.4.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecds.html">cds</a></li><li class="navelem"><a class="el" href="namespacecds_1_1gc.html">gc</a></li><li class="navelem"><a class="el" href="namespacecds_1_1gc_1_1hzp.html">hzp</a></li><li class="navelem"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html">GarbageCollector</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a>  </div>
  <div class="headertitle">
<div class="title">cds::gc::hzp::GarbageCollector Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Hazard Pointer singleton.  
 <a href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#details">More...</a></p>

<p><code>#include &lt;cds/gc/hzp/hzp.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcds_1_1gc_1_1hzp_1_1_garbage_collector_1_1hplist__node.html">hplist_node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal list of <a class="el" href="structcds_1_1gc_1_1hzp_1_1details_1_1_h_p_rec.html" title="Hazard pointer record of the thread.">cds::gc::hzp::details::HPRec</a>.  <a href="structcds_1_1gc_1_1hzp_1_1_garbage_collector_1_1hplist__node.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcds_1_1gc_1_1hzp_1_1_garbage_collector_1_1_internal_state.html">InternalState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal GC statistics.  <a href="structcds_1_1gc_1_1hzp_1_1_garbage_collector_1_1_internal_state.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcds_1_1gc_1_1hzp_1_1_garbage_collector_1_1_statistics.html">Statistics</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal GC statistics.  <a href="structcds_1_1gc_1_1hzp_1_1_garbage_collector_1_1_statistics.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a60e1779b0df2701d4c51418a7bb4d481"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a60e1779b0df2701d4c51418a7bb4d481"></a>
typedef <br class="typebreak"/>
<a class="el" href="classcds_1_1atomicity_1_1event__counter.html">cds::atomicity::event_counter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#a60e1779b0df2701d4c51418a7bb4d481">event_counter</a></td></tr>
<tr class="memdesc:a60e1779b0df2701d4c51418a7bb4d481"><td class="mdescLeft">&#160;</td><td class="mdescRight">event counter type <br/></td></tr>
<tr class="separator:a60e1779b0df2701d4c51418a7bb4d481"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a77b8ab2884857010aeaf192b0e83523b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a77b8ab2884857010aeaf192b0e83523b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#a77b8ab2884857010aeaf192b0e83523b">CDS_DECLARE_EXCEPTION</a> (HZPManagerEmpty,&quot;Global Hazard Pointer <a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html">GarbageCollector</a> is NULL&quot;)</td></tr>
<tr class="memdesc:a77b8ab2884857010aeaf192b0e83523b"><td class="mdescLeft">&#160;</td><td class="mdescRight">No <a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html" title="Hazard Pointer singleton.">GarbageCollector</a> object is created. <br/></td></tr>
<tr class="separator:a77b8ab2884857010aeaf192b0e83523b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10cf87cc78b7c3a5cea1d6ef208f4f93"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a10cf87cc78b7c3a5cea1d6ef208f4f93"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#a10cf87cc78b7c3a5cea1d6ef208f4f93">CDS_DECLARE_EXCEPTION</a> (HZPTooMany,&quot;Not enough required Hazard Pointer count&quot;)</td></tr>
<tr class="memdesc:a10cf87cc78b7c3a5cea1d6ef208f4f93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not enough required Hazard Pointer count. <br/></td></tr>
<tr class="separator:a10cf87cc78b7c3a5cea1d6ef208f4f93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8533c264f525949b4fdd3acd07585483"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8533c264f525949b4fdd3acd07585483"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#a8533c264f525949b4fdd3acd07585483">getHazardPointerCount</a> () const </td></tr>
<tr class="memdesc:a8533c264f525949b4fdd3acd07585483"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns max Hazard Pointer count defined in construction time. <br/></td></tr>
<tr class="separator:a8533c264f525949b4fdd3acd07585483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac880856b93166953a26f8c764b668e3c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac880856b93166953a26f8c764b668e3c"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#ac880856b93166953a26f8c764b668e3c">getMaxThreadCount</a> () const </td></tr>
<tr class="memdesc:ac880856b93166953a26f8c764b668e3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns max thread count defined in construction time. <br/></td></tr>
<tr class="separator:ac880856b93166953a26f8c764b668e3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa640f5cd380437f7ee649be15bcd4b23"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa640f5cd380437f7ee649be15bcd4b23"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#aa640f5cd380437f7ee649be15bcd4b23">getMaxRetiredPtrCount</a> () const </td></tr>
<tr class="memdesc:aa640f5cd380437f7ee649be15bcd4b23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns max size of retired objects array. It is defined in construction time. <br/></td></tr>
<tr class="separator:aa640f5cd380437f7ee649be15bcd4b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad985a9c7cd12f3ab2f2fa4fcae254d7f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad985a9c7cd12f3ab2f2fa4fcae254d7f"></a>
<a class="el" href="structcds_1_1gc_1_1hzp_1_1_garbage_collector_1_1_internal_state.html">InternalState</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#ad985a9c7cd12f3ab2f2fa4fcae254d7f">getInternalState</a> (<a class="el" href="structcds_1_1gc_1_1hzp_1_1_garbage_collector_1_1_internal_state.html">InternalState</a> &amp;stat) const </td></tr>
<tr class="memdesc:ad985a9c7cd12f3ab2f2fa4fcae254d7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get internal statistics. <br/></td></tr>
<tr class="separator:ad985a9c7cd12f3ab2f2fa4fcae254d7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae138f31cf537368b05a89622d73a0f81"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae138f31cf537368b05a89622d73a0f81"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#ae138f31cf537368b05a89622d73a0f81">isStatisticsEnabled</a> () const </td></tr>
<tr class="memdesc:ae138f31cf537368b05a89622d73a0f81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if internal statistics enabled. <br/></td></tr>
<tr class="separator:ae138f31cf537368b05a89622d73a0f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47b1c5520a9637e0420301020ddb3227"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a47b1c5520a9637e0420301020ddb3227"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#a47b1c5520a9637e0420301020ddb3227">enableStatistics</a> (bool bEnable)</td></tr>
<tr class="memdesc:a47b1c5520a9637e0420301020ddb3227"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables/disables internal statistics. <br/></td></tr>
<tr class="separator:a47b1c5520a9637e0420301020ddb3227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3d69104b13a2f6a3f9e9be8042127eb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac3d69104b13a2f6a3f9e9be8042127eb"></a>
<a class="el" href="namespacecds_1_1gc_1_1hzp.html#ac1ea43c18e08992e10581c8fbc06971d">scan_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#ac3d69104b13a2f6a3f9e9be8042127eb">getScanType</a> () const </td></tr>
<tr class="memdesc:ac3d69104b13a2f6a3f9e9be8042127eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current scan strategy. <br/></td></tr>
<tr class="separator:ac3d69104b13a2f6a3f9e9be8042127eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0321a557cbd6a787bb5134d805da33b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#ab0321a557cbd6a787bb5134d805da33b">setScanType</a> (<a class="el" href="namespacecds_1_1gc_1_1hzp.html#ac1ea43c18e08992e10581c8fbc06971d">scan_type</a> nScanType)</td></tr>
<tr class="memdesc:ab0321a557cbd6a787bb5134d805da33b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set current scan strategy.  <a href="#ab0321a557cbd6a787bb5134d805da33b">More...</a><br/></td></tr>
<tr class="separator:ab0321a557cbd6a787bb5134d805da33b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08b7b53870d9aabefcd7cb28e7997aeb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a08b7b53870d9aabefcd7cb28e7997aeb"></a>
<a class="el" href="structcds_1_1gc_1_1hzp_1_1details_1_1_h_p_rec.html">details::HPRec</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#a08b7b53870d9aabefcd7cb28e7997aeb">AllocateHPRec</a> ()</td></tr>
<tr class="memdesc:a08b7b53870d9aabefcd7cb28e7997aeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates Hazard Pointer GC record. For internal use only. <br/></td></tr>
<tr class="separator:a08b7b53870d9aabefcd7cb28e7997aeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae4a95cca765fdb510fb59b4466360e8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aae4a95cca765fdb510fb59b4466360e8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#aae4a95cca765fdb510fb59b4466360e8">RetireHPRec</a> (<a class="el" href="structcds_1_1gc_1_1hzp_1_1details_1_1_h_p_rec.html">details::HPRec</a> *pRec)</td></tr>
<tr class="memdesc:aae4a95cca765fdb510fb59b4466360e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free <a class="el" href="classcds_1_1gc_1_1_h_p.html" title="Hazard Pointer garbage collector.">HP</a> record. For internal use only. <br/></td></tr>
<tr class="separator:aae4a95cca765fdb510fb59b4466360e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01bb09f35b1062c4decffce171c5620d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#a01bb09f35b1062c4decffce171c5620d">Scan</a> (<a class="el" href="structcds_1_1gc_1_1hzp_1_1details_1_1_h_p_rec.html">details::HPRec</a> *pRec)</td></tr>
<tr class="memdesc:a01bb09f35b1062c4decffce171c5620d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The main garbage collecting function.  <a href="#a01bb09f35b1062c4decffce171c5620d">More...</a><br/></td></tr>
<tr class="separator:a01bb09f35b1062c4decffce171c5620d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e7056afcbc33c6cea9b32799f2e02d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#a9e7056afcbc33c6cea9b32799f2e02d0">HelpScan</a> (<a class="el" href="structcds_1_1gc_1_1hzp_1_1details_1_1_h_p_rec.html">details::HPRec</a> *pThis)</td></tr>
<tr class="memdesc:a9e7056afcbc33c6cea9b32799f2e02d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper scan routine.  <a href="#a9e7056afcbc33c6cea9b32799f2e02d0">More...</a><br/></td></tr>
<tr class="separator:a9e7056afcbc33c6cea9b32799f2e02d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a661b77fe748dc4c680fe7d93a10b8dae"><td class="memItemLeft" align="right" valign="top">static void CDS_STDCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#a661b77fe748dc4c680fe7d93a10b8dae">Construct</a> (size_t nHazardPtrCount=0, size_t nMaxThreadCount=0, size_t nMaxRetiredPtrCount=0, <a class="el" href="namespacecds_1_1gc_1_1hzp.html#ac1ea43c18e08992e10581c8fbc06971d">scan_type</a> nScanType=<a class="el" href="namespacecds_1_1gc_1_1hzp.html#ac1ea43c18e08992e10581c8fbc06971daca915f68d74c9f39f990e00a2766799e">inplace</a>)</td></tr>
<tr class="memdesc:a661b77fe748dc4c680fe7d93a10b8dae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates <a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html" title="Hazard Pointer singleton.">GarbageCollector</a> singleton.  <a href="#a661b77fe748dc4c680fe7d93a10b8dae">More...</a><br/></td></tr>
<tr class="separator:a661b77fe748dc4c680fe7d93a10b8dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac79c36f81454eb6002678dd3777b0a76"><td class="memItemLeft" align="right" valign="top">static void CDS_STDCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#ac79c36f81454eb6002678dd3777b0a76">Destruct</a> (bool bDetachAll=false)</td></tr>
<tr class="memdesc:ac79c36f81454eb6002678dd3777b0a76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys global instance of <a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html" title="Hazard Pointer singleton.">GarbageCollector</a>.  <a href="#ac79c36f81454eb6002678dd3777b0a76">More...</a><br/></td></tr>
<tr class="separator:ac79c36f81454eb6002678dd3777b0a76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3c1621f0149d267180733f03e06c0bc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab3c1621f0149d267180733f03e06c0bc"></a>
static <a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html">GarbageCollector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#ab3c1621f0149d267180733f03e06c0bc">instance</a> ()</td></tr>
<tr class="memdesc:ab3c1621f0149d267180733f03e06c0bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to <a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html" title="Hazard Pointer singleton.">GarbageCollector</a> instance. <br/></td></tr>
<tr class="separator:ab3c1621f0149d267180733f03e06c0bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade090e19517a5f78ec962a34293f67b2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ade090e19517a5f78ec962a34293f67b2"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#ade090e19517a5f78ec962a34293f67b2">isUsed</a> ()</td></tr>
<tr class="memdesc:ade090e19517a5f78ec962a34293f67b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if global GC object is constructed and may be used. <br/></td></tr>
<tr class="separator:ade090e19517a5f78ec962a34293f67b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca8ba27f700ea8628550f0087a6394eb"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#aca8ba27f700ea8628550f0087a6394eb">checkHPCount</a> (unsigned int nRequiredCount)</td></tr>
<tr class="memdesc:aca8ba27f700ea8628550f0087a6394eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks that required hazard pointer count <code>nRequiredCount</code> is less or equal then max hazard pointer count.  <a href="#aca8ba27f700ea8628550f0087a6394eb">More...</a><br/></td></tr>
<tr class="separator:aca8ba27f700ea8628550f0087a6394eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ad270c41d49a492134c6029a0733f567c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#ad270c41d49a492134c6029a0733f567c">classic_scan</a> (<a class="el" href="structcds_1_1gc_1_1hzp_1_1details_1_1_h_p_rec.html">details::HPRec</a> *pRec)</td></tr>
<tr class="memdesc:ad270c41d49a492134c6029a0733f567c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Classic scan algorithm.  <a href="#ad270c41d49a492134c6029a0733f567c">More...</a><br/></td></tr>
<tr class="separator:ad270c41d49a492134c6029a0733f567c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf7f45ee415a27a24f72433d4b33adfc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#adf7f45ee415a27a24f72433d4b33adfc">inplace_scan</a> (<a class="el" href="structcds_1_1gc_1_1hzp_1_1details_1_1_h_p_rec.html">details::HPRec</a> *pRec)</td></tr>
<tr class="memdesc:adf7f45ee415a27a24f72433d4b33adfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place scan algorithm.  <a href="#adf7f45ee415a27a24f72433d4b33adfc">More...</a><br/></td></tr>
<tr class="separator:adf7f45ee415a27a24f72433d4b33adfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a31dda8e3842b9d9fe0e6188311c6ff03"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#a31dda8e3842b9d9fe0e6188311c6ff03">GarbageCollector</a> (size_t nHazardPtrCount=0, size_t nMaxThreadCount=0, size_t nMaxRetiredPtrCount=0, <a class="el" href="namespacecds_1_1gc_1_1hzp.html#ac1ea43c18e08992e10581c8fbc06971d">scan_type</a> nScanType=<a class="el" href="namespacecds_1_1gc_1_1hzp.html#ac1ea43c18e08992e10581c8fbc06971daca915f68d74c9f39f990e00a2766799e">inplace</a>)</td></tr>
<tr class="memdesc:a31dda8e3842b9d9fe0e6188311c6ff03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ctor.  <a href="#a31dda8e3842b9d9fe0e6188311c6ff03">More...</a><br/></td></tr>
<tr class="separator:a31dda8e3842b9d9fe0e6188311c6ff03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac72af2c1c3de4dc0cbef2623624e63f9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac72af2c1c3de4dc0cbef2623624e63f9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#ac72af2c1c3de4dc0cbef2623624e63f9">~GarbageCollector</a> ()</td></tr>
<tr class="memdesc:ac72af2c1c3de4dc0cbef2623624e63f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dtor. <br/></td></tr>
<tr class="separator:ac72af2c1c3de4dc0cbef2623624e63f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae54bab023394c169aab592cf20e59077"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae54bab023394c169aab592cf20e59077"></a>
<a class="el" href="structcds_1_1gc_1_1hzp_1_1_garbage_collector_1_1hplist__node.html">hplist_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#ae54bab023394c169aab592cf20e59077">NewHPRec</a> ()</td></tr>
<tr class="memdesc:ae54bab023394c169aab592cf20e59077"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate new <a class="el" href="classcds_1_1gc_1_1_h_p.html" title="Hazard Pointer garbage collector.">HP</a> record. <br/></td></tr>
<tr class="separator:ae54bab023394c169aab592cf20e59077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a473247d2dcbe379c9c7e7a92b0dfec8a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#a473247d2dcbe379c9c7e7a92b0dfec8a">DeleteHPRec</a> (<a class="el" href="structcds_1_1gc_1_1hzp_1_1_garbage_collector_1_1hplist__node.html">hplist_node</a> *pNode)</td></tr>
<tr class="memdesc:a473247d2dcbe379c9c7e7a92b0dfec8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Permanently deletes HPrecord <code>pNode</code>.  <a href="#a473247d2dcbe379c9c7e7a92b0dfec8a">More...</a><br/></td></tr>
<tr class="separator:a473247d2dcbe379c9c7e7a92b0dfec8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbb722267c82e7bc69196d0346b3ad70"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#adbb722267c82e7bc69196d0346b3ad70">DeletePtr</a> (<a class="el" href="structcds_1_1gc_1_1details_1_1retired__ptr.html">details::retired_ptr</a> &amp;p)</td></tr>
<tr class="memdesc:adbb722267c82e7bc69196d0346b3ad70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Permanently deletes retired pointer <code>p</code>.  <a href="#adbb722267c82e7bc69196d0346b3ad70">More...</a><br/></td></tr>
<tr class="separator:adbb722267c82e7bc69196d0346b3ad70"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:adfaf88581455041c8ae1872df6259d91"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adfaf88581455041c8ae1872df6259d91"></a>
std::atomic&lt; <a class="el" href="structcds_1_1gc_1_1hzp_1_1_garbage_collector_1_1hplist__node.html">hplist_node</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#adfaf88581455041c8ae1872df6259d91">m_pListHead</a></td></tr>
<tr class="memdesc:adfaf88581455041c8ae1872df6259d91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Head of GC list. <br/></td></tr>
<tr class="separator:adfaf88581455041c8ae1872df6259d91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a820c23aadfcafce89a3f8c9f0c95ab65"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a820c23aadfcafce89a3f8c9f0c95ab65"></a>
<a class="el" href="structcds_1_1gc_1_1hzp_1_1_garbage_collector_1_1_statistics.html">Statistics</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#a820c23aadfcafce89a3f8c9f0c95ab65">m_Stat</a></td></tr>
<tr class="memdesc:a820c23aadfcafce89a3f8c9f0c95ab65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal statistics. <br/></td></tr>
<tr class="separator:a820c23aadfcafce89a3f8c9f0c95ab65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3001475b9ab9ff7789e33b241a8ea2b9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3001475b9ab9ff7789e33b241a8ea2b9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#a3001475b9ab9ff7789e33b241a8ea2b9">m_bStatEnabled</a></td></tr>
<tr class="memdesc:a3001475b9ab9ff7789e33b241a8ea2b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">true - statistics enabled <br/></td></tr>
<tr class="separator:a3001475b9ab9ff7789e33b241a8ea2b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08750cabd8d3dabdb3d82a464c924f1a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a08750cabd8d3dabdb3d82a464c924f1a"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#a08750cabd8d3dabdb3d82a464c924f1a">m_nHazardPointerCount</a></td></tr>
<tr class="memdesc:a08750cabd8d3dabdb3d82a464c924f1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">max count of thread's hazard pointer <br/></td></tr>
<tr class="separator:a08750cabd8d3dabdb3d82a464c924f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a824fff7e9b1d7cfcfaa60b7d1d1853d1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a824fff7e9b1d7cfcfaa60b7d1d1853d1"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#a824fff7e9b1d7cfcfaa60b7d1d1853d1">m_nMaxThreadCount</a></td></tr>
<tr class="memdesc:a824fff7e9b1d7cfcfaa60b7d1d1853d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">max count of thread <br/></td></tr>
<tr class="separator:a824fff7e9b1d7cfcfaa60b7d1d1853d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2199b0cb3b53d071359731bcfa02904"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad2199b0cb3b53d071359731bcfa02904"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#ad2199b0cb3b53d071359731bcfa02904">m_nMaxRetiredPtrCount</a></td></tr>
<tr class="memdesc:ad2199b0cb3b53d071359731bcfa02904"><td class="mdescLeft">&#160;</td><td class="mdescRight">max count of retired ptr per thread <br/></td></tr>
<tr class="separator:ad2199b0cb3b53d071359731bcfa02904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d721652b6a1b637065f82327028b914"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7d721652b6a1b637065f82327028b914"></a>
<a class="el" href="namespacecds_1_1gc_1_1hzp.html#ac1ea43c18e08992e10581c8fbc06971d">scan_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#a7d721652b6a1b637065f82327028b914">m_nScanType</a></td></tr>
<tr class="memdesc:a7d721652b6a1b637065f82327028b914"><td class="mdescLeft">&#160;</td><td class="mdescRight">scan type (see <a class="el" href="namespacecds_1_1gc_1_1hzp.html#ac1ea43c18e08992e10581c8fbc06971d">scan_type</a> enum) <br/></td></tr>
<tr class="separator:a7d721652b6a1b637065f82327028b914"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr class="memitem:a8fb10d9cadadffd5feb0c4eee087251c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8fb10d9cadadffd5feb0c4eee087251c"></a>
static <a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html">GarbageCollector</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#a8fb10d9cadadffd5feb0c4eee087251c">m_pHZPManager</a></td></tr>
<tr class="memdesc:a8fb10d9cadadffd5feb0c4eee087251c"><td class="mdescLeft">&#160;</td><td class="mdescRight">GC instance pointer. <br/></td></tr>
<tr class="separator:a8fb10d9cadadffd5feb0c4eee087251c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Hazard Pointer singleton. </p>
<p>Safe memory reclamation schema by Michael "Hazard Pointers"</p>
<dl class="section user"><dt>Sources:</dt><dd><ul>
<li>[2002] Maged M.Michael "Safe memory reclamation for dynamic lock-freeobjects using atomic reads and writes" </li>
<li>[2003] Maged M.Michael "Hazard Pointers: Safe memory reclamation for lock-free objects" </li>
<li>[2004] Andrei Alexandrescy, Maged Michael "Lock-free Data Structures with Hazard Pointers" </li>
</ul>
</dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a31dda8e3842b9d9fe0e6188311c6ff03"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cds::gc::hzp::GarbageCollector::GarbageCollector </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nHazardPtrCount</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nMaxThreadCount</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nMaxRetiredPtrCount</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecds_1_1gc_1_1hzp.html#ac1ea43c18e08992e10581c8fbc06971d">scan_type</a>&#160;</td>
          <td class="paramname"><em>nScanType</em> = <code><a class="el" href="namespacecds_1_1gc_1_1hzp.html#ac1ea43c18e08992e10581c8fbc06971daca915f68d74c9f39f990e00a2766799e">inplace</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ctor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nHazardPtrCount</td><td>Hazard pointer count per thread </td></tr>
    <tr><td class="paramname">nMaxThreadCount</td><td>Max count of thread </td></tr>
    <tr><td class="paramname">nMaxRetiredPtrCount</td><td>Capacity of the array of retired objects </td></tr>
    <tr><td class="paramname">nScanType</td><td>Scan type (see <a class="el" href="namespacecds_1_1gc_1_1hzp.html#ac1ea43c18e08992e10581c8fbc06971d">scan_type</a> enum) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aca8ba27f700ea8628550f0087a6394eb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void cds::gc::hzp::GarbageCollector::checkHPCount </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nRequiredCount</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks that required hazard pointer count <code>nRequiredCount</code> is less or equal then max hazard pointer count. </p>
<p>If <code>nRequiredCount</code> &gt; <a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#a8533c264f525949b4fdd3acd07585483" title="Returns max Hazard Pointer count defined in construction time.">getHazardPointerCount()</a> then the exception HZPTooMany is thrown </p>

</div>
</div>
<a class="anchor" id="ad270c41d49a492134c6029a0733f567c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cds::gc::hzp::GarbageCollector::classic_scan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcds_1_1gc_1_1hzp_1_1details_1_1_h_p_rec.html">details::HPRec</a> *&#160;</td>
          <td class="paramname"><em>pRec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Classic scan algorithm. </p>
<p>Classical scan algorithm as described in Michael's paper.</p>
<p>A scan includes four stages. The first stage involves scanning the array <a class="el" href="classcds_1_1gc_1_1_h_p.html" title="Hazard Pointer garbage collector.">HP</a> for non-null values. Whenever a non-null value is encountered, it is inserted in a local list of currently protected pointer. Only stage 1 accesses shared variables. The following stages operate only on private variables.</p>
<p>The second stage of a scan involves sorting local list of protected pointers to allow binary search in the third stage.</p>
<p>The third stage of a scan involves checking each reclaimed node against the pointers in local list of protected pointers. If the binary search yields no match, the node is freed. Otherwise, it cannot be deleted now and must kept in thread's list of reclaimed pointers.</p>
<p>The forth stage prepares new thread's private list of reclaimed pointers that could not be freed during the current scan, where they remain until the next scan.</p>
<p>This algorithm allocates memory for internal <a class="el" href="classcds_1_1gc_1_1_h_p.html" title="Hazard Pointer garbage collector.">HP</a> array.</p>
<p>This function is called internally by <a class="el" href="classcds_1_1gc_1_1hzp_1_1_thread_g_c.html" title="Thread&#39;s hazard pointer manager.">ThreadGC</a> object when upper bound of thread's list of reclaimed pointers is reached. </p>

</div>
</div>
<a class="anchor" id="a661b77fe748dc4c680fe7d93a10b8dae"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CDS_STDCALL cds::gc::hzp::GarbageCollector::Construct </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nHazardPtrCount</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nMaxThreadCount</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nMaxRetiredPtrCount</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecds_1_1gc_1_1hzp.html#ac1ea43c18e08992e10581c8fbc06971d">scan_type</a>&#160;</td>
          <td class="paramname"><em>nScanType</em> = <code><a class="el" href="namespacecds_1_1gc_1_1hzp.html#ac1ea43c18e08992e10581c8fbc06971daca915f68d74c9f39f990e00a2766799e">inplace</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates <a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html" title="Hazard Pointer singleton.">GarbageCollector</a> singleton. </p>
<p>GC is the singleton. If GC instance is not exist then the function creates the instance. Otherwise it does nothing.</p>
<p>The Michael's <a class="el" href="classcds_1_1gc_1_1_h_p.html" title="Hazard Pointer garbage collector.">HP</a> reclamation schema depends of three parameters:</p>
<p><code>nHazardPtrCount</code> - <a class="el" href="classcds_1_1gc_1_1_h_p.html" title="Hazard Pointer garbage collector.">HP</a> pointer count per thread. Usually it is small number (2-4) depending from the data structure algorithms. By default, if <code>nHazardPtrCount</code> = 0, the function uses maximum of <a class="el" href="classcds_1_1gc_1_1_h_p.html" title="Hazard Pointer garbage collector.">HP</a> count for CDS library.</p>
<p><code>nMaxThreadCount</code> - max count of thread with using <a class="el" href="classcds_1_1gc_1_1_h_p.html" title="Hazard Pointer garbage collector.">HP</a> GC in your application. Default is 100.</p>
<p><code>nMaxRetiredPtrCount</code> - capacity of array of retired pointers for each thread. Must be greater than <code>nHazardPtrCount</code> * <code>nMaxThreadCount</code>. Default is 2 * <code>nHazardPtrCount</code> * <code>nMaxThreadCount</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nHazardPtrCount</td><td>Hazard pointer count per thread </td></tr>
    <tr><td class="paramname">nMaxThreadCount</td><td>Max count of simultaneous working thread in your application </td></tr>
    <tr><td class="paramname">nMaxRetiredPtrCount</td><td>Capacity of the array of retired objects for the thread </td></tr>
    <tr><td class="paramname">nScanType</td><td>Scan type (see <a class="el" href="namespacecds_1_1gc_1_1hzp.html#ac1ea43c18e08992e10581c8fbc06971d">scan_type</a> enum) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a473247d2dcbe379c9c7e7a92b0dfec8a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cds::gc::hzp::GarbageCollector::DeleteHPRec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcds_1_1gc_1_1hzp_1_1_garbage_collector_1_1hplist__node.html">hplist_node</a> *&#160;</td>
          <td class="paramname"><em>pNode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Permanently deletes HPrecord <code>pNode</code>. </p>
<p>Caveat: for performance reason this function is defined as inline and cannot be called directly </p>

</div>
</div>
<a class="anchor" id="adbb722267c82e7bc69196d0346b3ad70"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cds::gc::hzp::GarbageCollector::DeletePtr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcds_1_1gc_1_1details_1_1retired__ptr.html">details::retired_ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Permanently deletes retired pointer <code>p</code>. </p>
<p>Caveat: for performance reason this function is defined as inline and cannot be called directly </p>

</div>
</div>
<a class="anchor" id="ac79c36f81454eb6002678dd3777b0a76"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CDS_STDCALL cds::gc::hzp::GarbageCollector::Destruct </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bDetachAll</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys global instance of <a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html" title="Hazard Pointer singleton.">GarbageCollector</a>. </p>
<p>The parameter <code>bDetachAll</code> should be used carefully: if its value is <code>true</code>, then the destroying GC automatically detaches all attached threads. This feature can be useful when you have no control over the thread termination, for example, when <code>libcds</code> is injected into existing external thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bDetachAll</td><td>Detach all threads </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9e7056afcbc33c6cea9b32799f2e02d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cds::gc::hzp::GarbageCollector::HelpScan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcds_1_1gc_1_1hzp_1_1details_1_1_h_p_rec.html">details::HPRec</a> *&#160;</td>
          <td class="paramname"><em>pThis</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper scan routine. </p>
<p>The function guarantees that every node that is eligible for reuse is eventually freed, barring thread failures. To do so, after executing Scan, a thread executes a HelpScan, where it checks every <a class="el" href="classcds_1_1gc_1_1_h_p.html" title="Hazard Pointer garbage collector.">HP</a> record. If an <a class="el" href="classcds_1_1gc_1_1_h_p.html" title="Hazard Pointer garbage collector.">HP</a> record is inactive, the thread moves all "lost" reclaimed pointers to thread's list of reclaimed pointers.</p>
<p>The function is called internally by Scan. </p>

</div>
</div>
<a class="anchor" id="adf7f45ee415a27a24f72433d4b33adfc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cds::gc::hzp::GarbageCollector::inplace_scan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcds_1_1gc_1_1hzp_1_1details_1_1_h_p_rec.html">details::HPRec</a> *&#160;</td>
          <td class="paramname"><em>pRec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place scan algorithm. </p>
<p>Unlike the <a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#ad270c41d49a492134c6029a0733f567c">classic_scan</a> algorithm, <code>inplace_scan</code> does not allocate any memory. All operations are performed in-place. </p>

</div>
</div>
<a class="anchor" id="a01bb09f35b1062c4decffce171c5620d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cds::gc::hzp::GarbageCollector::Scan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcds_1_1gc_1_1hzp_1_1details_1_1_h_p_rec.html">details::HPRec</a> *&#160;</td>
          <td class="paramname"><em>pRec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The main garbage collecting function. </p>
<p>This function is called internally by <a class="el" href="classcds_1_1gc_1_1hzp_1_1_thread_g_c.html" title="Thread&#39;s hazard pointer manager.">ThreadGC</a> object when upper bound of thread's list of reclaimed pointers is reached.</p>
<p>There are the following scan algorithm:</p>
<ul>
<li><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#ad270c41d49a492134c6029a0733f567c">classic_scan</a> allocates memory for internal use</li>
<li><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#adf7f45ee415a27a24f72433d4b33adfc">inplace_scan</a> does not allocate any memory</li>
</ul>
<p>Use <a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#ab0321a557cbd6a787bb5134d805da33b">setScanType</a> function to setup appropriate scan algorithm. </p>

</div>
</div>
<a class="anchor" id="ab0321a557cbd6a787bb5134d805da33b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cds::gc::hzp::GarbageCollector::setScanType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecds_1_1gc_1_1hzp.html#ac1ea43c18e08992e10581c8fbc06971d">scan_type</a>&#160;</td>
          <td class="paramname"><em>nScanType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set current scan strategy. </p>
<p>Scan strategy changing is allowed on the fly. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nScanType</td><td>new scan strategy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>cds/gc/hzp/hzp.h</li>
</ul>
</div><!-- contents -->
		<hr/>
		<div align="right">
			<b>cds</b> <b>1.4.0</b> 
			Developed by <i>Maxim Khiszinsky aka khizmax</i> 2007 - 2012
			<br/>
			<i>Autogenerated Mon May 20 2013 00:37:59 by Doxygen 1.8.3.1</i>
		</div>
	</BODY>
</HTML>
