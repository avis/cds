<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>cds: cds::container::CuckooMap&lt; Key, T, Traits &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">cds
   &#160;<span id="projectnumber">1.4.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecds.html">cds</a></li><li class="navelem"><a class="el" href="namespacecds_1_1container.html">container</a></li><li class="navelem"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html">CuckooMap</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a>  </div>
  <div class="headertitle">
<div class="title">cds::container::CuckooMap&lt; Key, T, Traits &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__cds__nonintrusive__map.html">Maps and Sets</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Cuckoo hash map.  
 <a href="classcds_1_1container_1_1_cuckoo_map.html#details">More...</a></p>

<p><code>#include &lt;cds/container/cuckoo_map.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for cds::container::CuckooMap&lt; Key, T, Traits &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcds_1_1container_1_1_cuckoo_map.png" usemap="#cds::container::CuckooMap&lt; Key, T, Traits &gt;_map" alt=""/>
  <map id="cds::container::CuckooMap&lt; Key, T, Traits &gt;_map" name="cds::container::CuckooMap&lt; Key, T, Traits &gt;_map">
<area href="classcds_1_1intrusive_1_1_cuckoo_set.html" alt="cds::intrusive::CuckooSet&lt; std::pair&lt; Key const, T &gt;, Traits &gt;" shape="rect" coords="0,0,358,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a3da032600868e73a64b352ee8fde1ad2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3da032600868e73a64b352ee8fde1ad2"></a>
typedef Key&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a3da032600868e73a64b352ee8fde1ad2">key_type</a></td></tr>
<tr class="memdesc:a3da032600868e73a64b352ee8fde1ad2"><td class="mdescLeft">&#160;</td><td class="mdescRight">key type <br/></td></tr>
<tr class="separator:a3da032600868e73a64b352ee8fde1ad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab64c43804999ac92124b547ee9d35721"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab64c43804999ac92124b547ee9d35721"></a>
typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#ab64c43804999ac92124b547ee9d35721">mapped_type</a></td></tr>
<tr class="memdesc:ab64c43804999ac92124b547ee9d35721"><td class="mdescLeft">&#160;</td><td class="mdescRight">value type stored in the container <br/></td></tr>
<tr class="separator:ab64c43804999ac92124b547ee9d35721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b7029bea19087f7565784426abffcba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6b7029bea19087f7565784426abffcba"></a>
typedef std::pair&lt; <a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a3da032600868e73a64b352ee8fde1ad2">key_type</a> <br class="typebreak"/>
const, <a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#ab64c43804999ac92124b547ee9d35721">mapped_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a6b7029bea19087f7565784426abffcba">value_type</a></td></tr>
<tr class="memdesc:a6b7029bea19087f7565784426abffcba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key-value pair type stored in the map. <br/></td></tr>
<tr class="separator:a6b7029bea19087f7565784426abffcba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac2d83653f3d60c6eda8853d01450392"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aac2d83653f3d60c6eda8853d01450392"></a>
typedef Traits&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#aac2d83653f3d60c6eda8853d01450392">options</a></td></tr>
<tr class="memdesc:aac2d83653f3d60c6eda8853d01450392"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits <br/></td></tr>
<tr class="separator:aac2d83653f3d60c6eda8853d01450392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a8e673f70c3333a37496b531f3402a5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8a8e673f70c3333a37496b531f3402a5"></a>
typedef options::hash&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a8a8e673f70c3333a37496b531f3402a5">hash</a></td></tr>
<tr class="memdesc:a8a8e673f70c3333a37496b531f3402a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">hash functor tuple wrapped for internal use <br/></td></tr>
<tr class="separator:a8a8e673f70c3333a37496b531f3402a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a875c8c5ecc6c99c802d7368b76cd1486"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a875c8c5ecc6c99c802d7368b76cd1486"></a>
typedef base_class::hash_tuple_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a875c8c5ecc6c99c802d7368b76cd1486">hash_tuple_type</a></td></tr>
<tr class="memdesc:a875c8c5ecc6c99c802d7368b76cd1486"><td class="mdescLeft">&#160;</td><td class="mdescRight">hash tuple type <br/></td></tr>
<tr class="separator:a875c8c5ecc6c99c802d7368b76cd1486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bf312f1c91e71a6a74d196b5812cd58"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5bf312f1c91e71a6a74d196b5812cd58"></a>
typedef base_class::mutex_policy&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a5bf312f1c91e71a6a74d196b5812cd58">mutex_policy</a></td></tr>
<tr class="memdesc:a5bf312f1c91e71a6a74d196b5812cd58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concurrent access policy, see <a class="el" href="structcds_1_1container_1_1cuckoo_1_1type__traits.html#ade446cfe4dd89001f2e0b011af348365" title="Concurrent access policy.">cuckoo::type_traits::mutex_policy</a>. <br/></td></tr>
<tr class="separator:a5bf312f1c91e71a6a74d196b5812cd58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee847170d3b27c1e04991cf696e2fbb1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aee847170d3b27c1e04991cf696e2fbb1"></a>
typedef base_class::stat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#aee847170d3b27c1e04991cf696e2fbb1">stat</a></td></tr>
<tr class="memdesc:aee847170d3b27c1e04991cf696e2fbb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal statistics type <br/></td></tr>
<tr class="separator:aee847170d3b27c1e04991cf696e2fbb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2058c35e17dd2ddb9e855651d0767417"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2058c35e17dd2ddb9e855651d0767417"></a>
typedef base_class::key_equal_to&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a2058c35e17dd2ddb9e855651d0767417">key_equal_to</a></td></tr>
<tr class="memdesc:a2058c35e17dd2ddb9e855651d0767417"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key equality functor; used only for unordered probe-set. <br/></td></tr>
<tr class="separator:a2058c35e17dd2ddb9e855651d0767417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a068b7713f5bb6a55525a5cbbdcf1af71"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a068b7713f5bb6a55525a5cbbdcf1af71"></a>
typedef base_class::key_comparator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a068b7713f5bb6a55525a5cbbdcf1af71">key_comparator</a></td></tr>
<tr class="memdesc:a068b7713f5bb6a55525a5cbbdcf1af71"><td class="mdescLeft">&#160;</td><td class="mdescRight">key comparing functor based on <a class="el" href="structcds_1_1opt_1_1compare.html" title="[type-option] Option setter for key comparing">opt::compare</a> and <a class="el" href="structcds_1_1opt_1_1less.html" title="[type-option] Option setter for less predicate">opt::less</a> option setter. Used only for ordered probe set <br/></td></tr>
<tr class="separator:a068b7713f5bb6a55525a5cbbdcf1af71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe85994f6767c7a70837925330784d00"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abe85994f6767c7a70837925330784d00"></a>
typedef base_class::allocator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#abe85994f6767c7a70837925330784d00">allocator</a></td></tr>
<tr class="memdesc:abe85994f6767c7a70837925330784d00"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocator type used for internal bucket table allocations <br/></td></tr>
<tr class="separator:abe85994f6767c7a70837925330784d00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf256ba378825d36a7442a9d8147537d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acf256ba378825d36a7442a9d8147537d"></a>
typedef std::conditional<br class="typebreak"/>
&lt; std::is_same&lt; typename <br class="typebreak"/>
options::node_allocator, <br class="typebreak"/>
<a class="el" href="structcds_1_1opt_1_1none.html">opt::none</a> &gt;::value, <a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#abe85994f6767c7a70837925330784d00">allocator</a>, <br class="typebreak"/>
typename <br class="typebreak"/>
options::node_allocator &gt;<br class="typebreak"/>
::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#acf256ba378825d36a7442a9d8147537d">node_allocator</a></td></tr>
<tr class="memdesc:acf256ba378825d36a7442a9d8147537d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node allocator type. <br/></td></tr>
<tr class="separator:acf256ba378825d36a7442a9d8147537d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e599ed58b1fc3a5f509971db4453e61"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7e599ed58b1fc3a5f509971db4453e61"></a>
typedef options::item_counter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a7e599ed58b1fc3a5f509971db4453e61">item_counter</a></td></tr>
<tr class="memdesc:a7e599ed58b1fc3a5f509971db4453e61"><td class="mdescLeft">&#160;</td><td class="mdescRight">item counter type <br/></td></tr>
<tr class="separator:a7e599ed58b1fc3a5f509971db4453e61"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a341c7da08ef0c77406969e8414e71b9d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a341c7da08ef0c77406969e8414e71b9d">CuckooMap</a> ()</td></tr>
<tr class="memdesc:a341c7da08ef0c77406969e8414e71b9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#a341c7da08ef0c77406969e8414e71b9d">More...</a><br/></td></tr>
<tr class="separator:a341c7da08ef0c77406969e8414e71b9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9004754391ab93c87e581461b63fbb44"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a9004754391ab93c87e581461b63fbb44">CuckooMap</a> (size_t nInitialSize, unsigned int nProbesetSize, unsigned int nProbesetThreshold=0)</td></tr>
<tr class="memdesc:a9004754391ab93c87e581461b63fbb44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an object with given probe set size and threshold.  <a href="#a9004754391ab93c87e581461b63fbb44">More...</a><br/></td></tr>
<tr class="separator:a9004754391ab93c87e581461b63fbb44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a779df6d9d36dc26634173734b851d277"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a779df6d9d36dc26634173734b851d277">CuckooMap</a> (<a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a875c8c5ecc6c99c802d7368b76cd1486">hash_tuple_type</a> const &amp;h)</td></tr>
<tr class="memdesc:a779df6d9d36dc26634173734b851d277"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an object with given hash functor tuple.  <a href="#a779df6d9d36dc26634173734b851d277">More...</a><br/></td></tr>
<tr class="separator:a779df6d9d36dc26634173734b851d277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac976f4836e512daeabfff6683f43d323"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#ac976f4836e512daeabfff6683f43d323">CuckooMap</a> (size_t nInitialSize, unsigned int nProbesetSize, unsigned int nProbesetThreshold, <a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a875c8c5ecc6c99c802d7368b76cd1486">hash_tuple_type</a> const &amp;h)</td></tr>
<tr class="memdesc:ac976f4836e512daeabfff6683f43d323"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a map with given probe set properties and hash functor tuple.  <a href="#ac976f4836e512daeabfff6683f43d323">More...</a><br/></td></tr>
<tr class="separator:ac976f4836e512daeabfff6683f43d323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16fd32ddba075fca3ffe33c44181fdb6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a16fd32ddba075fca3ffe33c44181fdb6">CuckooMap</a> (<a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a875c8c5ecc6c99c802d7368b76cd1486">hash_tuple_type</a> &amp;&amp;h)</td></tr>
<tr class="memdesc:a16fd32ddba075fca3ffe33c44181fdb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a map with given hash functor tuple (move semantics)  <a href="#a16fd32ddba075fca3ffe33c44181fdb6">More...</a><br/></td></tr>
<tr class="separator:a16fd32ddba075fca3ffe33c44181fdb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bf609fe428c69dd4f794a7936bb6428"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a9bf609fe428c69dd4f794a7936bb6428">CuckooMap</a> (size_t nInitialSize, unsigned int nProbesetSize, unsigned int nProbesetThreshold, <a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a875c8c5ecc6c99c802d7368b76cd1486">hash_tuple_type</a> &amp;&amp;h)</td></tr>
<tr class="memdesc:a9bf609fe428c69dd4f794a7936bb6428"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a map with given probe set properties and hash functor tuple (move semantics)  <a href="#a9bf609fe428c69dd4f794a7936bb6428">More...</a><br/></td></tr>
<tr class="separator:a9bf609fe428c69dd4f794a7936bb6428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70fdc0789a9930b1fff07592f8085ceb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a70fdc0789a9930b1fff07592f8085ceb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a70fdc0789a9930b1fff07592f8085ceb">~CuckooMap</a> ()</td></tr>
<tr class="memdesc:a70fdc0789a9930b1fff07592f8085ceb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor clears the map. <br/></td></tr>
<tr class="separator:a70fdc0789a9930b1fff07592f8085ceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a305d109764c5685e2f8d649c15f0ebc7"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:a305d109764c5685e2f8d649c15f0ebc7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a305d109764c5685e2f8d649c15f0ebc7">insert</a> (K const &amp;key)</td></tr>
<tr class="memdesc:a305d109764c5685e2f8d649c15f0ebc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node with key and default value.  <a href="#a305d109764c5685e2f8d649c15f0ebc7">More...</a><br/></td></tr>
<tr class="separator:a305d109764c5685e2f8d649c15f0ebc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac30d8a9a5bff3cf218c0f55809bc12bf"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V &gt; </td></tr>
<tr class="memitem:ac30d8a9a5bff3cf218c0f55809bc12bf"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#ac30d8a9a5bff3cf218c0f55809bc12bf">insert</a> (K const &amp;key, V const &amp;val)</td></tr>
<tr class="memdesc:ac30d8a9a5bff3cf218c0f55809bc12bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="#ac30d8a9a5bff3cf218c0f55809bc12bf">More...</a><br/></td></tr>
<tr class="separator:ac30d8a9a5bff3cf218c0f55809bc12bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace105631ebfba013e761db058a96648a"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Func &gt; </td></tr>
<tr class="memitem:ace105631ebfba013e761db058a96648a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#ace105631ebfba013e761db058a96648a">insert_key</a> (const K &amp;key, Func func)</td></tr>
<tr class="memdesc:ace105631ebfba013e761db058a96648a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node and initialize it by a functor.  <a href="#ace105631ebfba013e761db058a96648a">More...</a><br/></td></tr>
<tr class="separator:ace105631ebfba013e761db058a96648a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7b5dac039c3782313e7491e84679f8e"><td class="memTemplParams" colspan="2">template&lt;typename K , typename... Args&gt; </td></tr>
<tr class="memitem:ae7b5dac039c3782313e7491e84679f8e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#ae7b5dac039c3782313e7491e84679f8e">emplace</a> (K &amp;&amp;key, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:ae7b5dac039c3782313e7491e84679f8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">For key <code>key</code> inserts data of type <a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a6b7029bea19087f7565784426abffcba">value_type</a> constructed with <code>std::forward&lt;Args&gt;(args)...</code>  <a href="#ae7b5dac039c3782313e7491e84679f8e">More...</a><br/></td></tr>
<tr class="separator:ae7b5dac039c3782313e7491e84679f8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c858c39f5a5fd11a00a56da4226b303"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Func &gt; </td></tr>
<tr class="memitem:a1c858c39f5a5fd11a00a56da4226b303"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; bool, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a1c858c39f5a5fd11a00a56da4226b303">ensure</a> (K const &amp;key, Func func)</td></tr>
<tr class="memdesc:a1c858c39f5a5fd11a00a56da4226b303"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures that the <code>key</code> exists in the map.  <a href="#a1c858c39f5a5fd11a00a56da4226b303">More...</a><br/></td></tr>
<tr class="separator:a1c858c39f5a5fd11a00a56da4226b303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a949108e97bfa54780ef4816ba0db2ef0"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:a949108e97bfa54780ef4816ba0db2ef0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a949108e97bfa54780ef4816ba0db2ef0">erase</a> (K const &amp;key)</td></tr>
<tr class="memdesc:a949108e97bfa54780ef4816ba0db2ef0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete <code>key</code> from the map.  <a href="#a949108e97bfa54780ef4816ba0db2ef0">More...</a><br/></td></tr>
<tr class="separator:a949108e97bfa54780ef4816ba0db2ef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a773b90f2861fd07a205b1d7113a2faee"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Predicate &gt; </td></tr>
<tr class="memitem:a773b90f2861fd07a205b1d7113a2faee"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a773b90f2861fd07a205b1d7113a2faee">erase_with</a> (K const &amp;key, Predicate pred)</td></tr>
<tr class="memdesc:a773b90f2861fd07a205b1d7113a2faee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the list using <code>pred</code> predicate for searching.  <a href="#a773b90f2861fd07a205b1d7113a2faee">More...</a><br/></td></tr>
<tr class="separator:a773b90f2861fd07a205b1d7113a2faee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadddd9a1a41b940289a1f7efdf78fcae"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Func &gt; </td></tr>
<tr class="memitem:aadddd9a1a41b940289a1f7efdf78fcae"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#aadddd9a1a41b940289a1f7efdf78fcae">erase</a> (K const &amp;key, Func f)</td></tr>
<tr class="memdesc:aadddd9a1a41b940289a1f7efdf78fcae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete <code>key</code> from the map.  <a href="#aadddd9a1a41b940289a1f7efdf78fcae">More...</a><br/></td></tr>
<tr class="separator:aadddd9a1a41b940289a1f7efdf78fcae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89acd3bfb03ea7705a91f05af79e0be9"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Predicate , typename Func &gt; </td></tr>
<tr class="memitem:a89acd3bfb03ea7705a91f05af79e0be9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a89acd3bfb03ea7705a91f05af79e0be9">erase_with</a> (K const &amp;key, Predicate pred, Func f)</td></tr>
<tr class="memdesc:a89acd3bfb03ea7705a91f05af79e0be9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the list using <code>pred</code> predicate for searching.  <a href="#a89acd3bfb03ea7705a91f05af79e0be9">More...</a><br/></td></tr>
<tr class="separator:a89acd3bfb03ea7705a91f05af79e0be9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49e55b628a859e446f9751046c8fa464"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Func &gt; </td></tr>
<tr class="memitem:a49e55b628a859e446f9751046c8fa464"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a49e55b628a859e446f9751046c8fa464">find</a> (K const &amp;key, Func f)</td></tr>
<tr class="memdesc:a49e55b628a859e446f9751046c8fa464"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the key <code>key</code>.  <a href="#a49e55b628a859e446f9751046c8fa464">More...</a><br/></td></tr>
<tr class="separator:a49e55b628a859e446f9751046c8fa464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0944519780b201d3f0e265f73e47771"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Predicate , typename Func &gt; </td></tr>
<tr class="memitem:ac0944519780b201d3f0e265f73e47771"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#ac0944519780b201d3f0e265f73e47771">find_with</a> (K const &amp;key, Predicate pred, Func f)</td></tr>
<tr class="memdesc:ac0944519780b201d3f0e265f73e47771"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the key <code>val</code> using <code>pred</code> predicate for comparing.  <a href="#ac0944519780b201d3f0e265f73e47771">More...</a><br/></td></tr>
<tr class="separator:ac0944519780b201d3f0e265f73e47771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae563694c48009a3a821c2d1b0740505d"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:ae563694c48009a3a821c2d1b0740505d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#ae563694c48009a3a821c2d1b0740505d">find</a> (K const &amp;key)</td></tr>
<tr class="memdesc:ae563694c48009a3a821c2d1b0740505d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the key <code>key</code>.  <a href="#ae563694c48009a3a821c2d1b0740505d">More...</a><br/></td></tr>
<tr class="separator:ae563694c48009a3a821c2d1b0740505d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fdacec37e7b9f23998123ee902194a2"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Predicate &gt; </td></tr>
<tr class="memitem:a4fdacec37e7b9f23998123ee902194a2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a4fdacec37e7b9f23998123ee902194a2">find_with</a> (K const &amp;key, Predicate pred)</td></tr>
<tr class="memdesc:a4fdacec37e7b9f23998123ee902194a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the key <code>val</code> using <code>pred</code> predicate for comparing.  <a href="#a4fdacec37e7b9f23998123ee902194a2">More...</a><br/></td></tr>
<tr class="separator:a4fdacec37e7b9f23998123ee902194a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54eca2d1f3c7e56e0532d6ec969ca67e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a54eca2d1f3c7e56e0532d6ec969ca67e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a54eca2d1f3c7e56e0532d6ec969ca67e">clear</a> ()</td></tr>
<tr class="memdesc:a54eca2d1f3c7e56e0532d6ec969ca67e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the map. <br/></td></tr>
<tr class="separator:a54eca2d1f3c7e56e0532d6ec969ca67e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13dd080b264b73565911c99c760116c2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a13dd080b264b73565911c99c760116c2">empty</a> () const </td></tr>
<tr class="memdesc:a13dd080b264b73565911c99c760116c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the map is empty.  <a href="#a13dd080b264b73565911c99c760116c2">More...</a><br/></td></tr>
<tr class="separator:a13dd080b264b73565911c99c760116c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3a4887444dbbc370563a399442d6a64"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad3a4887444dbbc370563a399442d6a64"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#ad3a4887444dbbc370563a399442d6a64">size</a> () const </td></tr>
<tr class="memdesc:ad3a4887444dbbc370563a399442d6a64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns item count in the map. <br/></td></tr>
<tr class="separator:ad3a4887444dbbc370563a399442d6a64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53711b0378aab7e54012f772657c8637"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a53711b0378aab7e54012f772657c8637">bucket_count</a> () const </td></tr>
<tr class="memdesc:a53711b0378aab7e54012f772657c8637"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of hash table.  <a href="#a53711b0378aab7e54012f772657c8637">More...</a><br/></td></tr>
<tr class="separator:a53711b0378aab7e54012f772657c8637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f84095546cb5c807d5927286933a408"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a7f84095546cb5c807d5927286933a408">lock_count</a> () const </td></tr>
<tr class="memdesc:a7f84095546cb5c807d5927286933a408"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns lock array size.  <a href="#a7f84095546cb5c807d5927286933a408">More...</a><br/></td></tr>
<tr class="separator:a7f84095546cb5c807d5927286933a408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a224fc555e3673a0bf2bb6f528e36c6da"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a224fc555e3673a0bf2bb6f528e36c6da"></a>
<a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#aee847170d3b27c1e04991cf696e2fbb1">stat</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a224fc555e3673a0bf2bb6f528e36c6da">statistics</a> () const </td></tr>
<tr class="memdesc:a224fc555e3673a0bf2bb6f528e36c6da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const reference to internal statistics. <br/></td></tr>
<tr class="separator:a224fc555e3673a0bf2bb6f528e36c6da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4392b6221664c16a5d357fd274f8cadd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4392b6221664c16a5d357fd274f8cadd"></a>
mutex_policy::statistics_type <br class="typebreak"/>
const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a4392b6221664c16a5d357fd274f8cadd">mutex_policy_statistics</a> () const </td></tr>
<tr class="memdesc:a4392b6221664c16a5d357fd274f8cadd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const reference to mutex policy internal statistics. <br/></td></tr>
<tr class="separator:a4392b6221664c16a5d357fd274f8cadd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:ab2b0729de5896dc0e998ae4301747262"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab2b0729de5896dc0e998ae4301747262"></a>
static bool const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#ab2b0729de5896dc0e998ae4301747262">c_isSorted</a> = base_class::c_isSorted</td></tr>
<tr class="memdesc:ab2b0729de5896dc0e998ae4301747262"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether the probe set should be ordered <br/></td></tr>
<tr class="separator:ab2b0729de5896dc0e998ae4301747262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35537f20a82788a4fa973c9f894ba74c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a35537f20a82788a4fa973c9f894ba74c"></a>
static size_t const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a35537f20a82788a4fa973c9f894ba74c">c_nArity</a> = base_class::c_nArity</td></tr>
<tr class="memdesc:a35537f20a82788a4fa973c9f894ba74c"><td class="mdescLeft">&#160;</td><td class="mdescRight">the arity of cuckoo hashing: the number of hash functors provided; minimum 2. <br/></td></tr>
<tr class="separator:a35537f20a82788a4fa973c9f894ba74c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f7cdc6c06a45355e7616eacd12a361b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3f7cdc6c06a45355e7616eacd12a361b"></a>
static unsigned int const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a3f7cdc6c06a45355e7616eacd12a361b">c_nDefaultProbesetSize</a> = base_class::c_nDefaultProbesetSize</td></tr>
<tr class="memdesc:a3f7cdc6c06a45355e7616eacd12a361b"><td class="mdescLeft">&#160;</td><td class="mdescRight">default probeset size <br/></td></tr>
<tr class="separator:a3f7cdc6c06a45355e7616eacd12a361b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92aad97a2dd8a8cc65dd6015e95512b3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a92aad97a2dd8a8cc65dd6015e95512b3"></a>
static size_t const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a92aad97a2dd8a8cc65dd6015e95512b3">c_nDefaultInitialSize</a> = base_class::c_nDefaultInitialSize</td></tr>
<tr class="memdesc:a92aad97a2dd8a8cc65dd6015e95512b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">default initial size <br/></td></tr>
<tr class="separator:a92aad97a2dd8a8cc65dd6015e95512b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2856c245ac428436491bec80a650fc4b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2856c245ac428436491bec80a650fc4b"></a>
static unsigned int const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a2856c245ac428436491bec80a650fc4b">c_nRelocateLimit</a> = base_class::c_nRelocateLimit</td></tr>
<tr class="memdesc:a2856c245ac428436491bec80a650fc4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count of attempts to relocate before giving up. <br/></td></tr>
<tr class="separator:a2856c245ac428436491bec80a650fc4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classcds_1_1intrusive_1_1_cuckoo_set')"><img src="closed.png" alt="-"/>&#160;Protected Types inherited from <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html">cds::intrusive::CuckooSet&lt; std::pair&lt; Key const, T &gt;, Traits &gt;</a></td></tr>
<tr class="memitem:a80f3988a87de588e0a2d873592e6da40 inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a80f3988a87de588e0a2d873592e6da40"></a>
typedef std::pair&lt; Key const, T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a80f3988a87de588e0a2d873592e6da40">value_type</a></td></tr>
<tr class="memdesc:a80f3988a87de588e0a2d873592e6da40 inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value type stored in the set. <br/></td></tr>
<tr class="separator:a80f3988a87de588e0a2d873592e6da40 inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec37050e433a8c1d925eda572252fb0d inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec37050e433a8c1d925eda572252fb0d"></a>
typedef Traits&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#aec37050e433a8c1d925eda572252fb0d">options</a></td></tr>
<tr class="memdesc:aec37050e433a8c1d925eda572252fb0d inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set traits. <br/></td></tr>
<tr class="separator:aec37050e433a8c1d925eda572252fb0d inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa4cc5921f54a8b8c796699cad5ada8c inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaa4cc5921f54a8b8c796699cad5ada8c"></a>
typedef options::hook&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#aaa4cc5921f54a8b8c796699cad5ada8c">hook</a></td></tr>
<tr class="memdesc:aaa4cc5921f54a8b8c796699cad5ada8c inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">hook type <br/></td></tr>
<tr class="separator:aaa4cc5921f54a8b8c796699cad5ada8c inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11d55d2a0fff222284b2d978b7a0985d inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a11d55d2a0fff222284b2d978b7a0985d"></a>
typedef hook::node_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a11d55d2a0fff222284b2d978b7a0985d">node_type</a></td></tr>
<tr class="memdesc:a11d55d2a0fff222284b2d978b7a0985d inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">node type <br/></td></tr>
<tr class="separator:a11d55d2a0fff222284b2d978b7a0985d inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9af0e1eb823a6d2f1c557686c912c605 inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9af0e1eb823a6d2f1c557686c912c605"></a>
typedef <a class="el" href="structcds_1_1intrusive_1_1get__node__traits.html">get_node_traits</a><br class="typebreak"/>
&lt; <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a80f3988a87de588e0a2d873592e6da40">value_type</a>, <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a11d55d2a0fff222284b2d978b7a0985d">node_type</a>, <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#aaa4cc5921f54a8b8c796699cad5ada8c">hook</a> &gt;<br class="typebreak"/>
::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a9af0e1eb823a6d2f1c557686c912c605">node_traits</a></td></tr>
<tr class="memdesc:a9af0e1eb823a6d2f1c557686c912c605 inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">node traits <br/></td></tr>
<tr class="separator:a9af0e1eb823a6d2f1c557686c912c605 inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a634e9cab4969a594206b1a76e87b8ee1 inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a634e9cab4969a594206b1a76e87b8ee1"></a>
typedef options::hash&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a634e9cab4969a594206b1a76e87b8ee1">hash</a></td></tr>
<tr class="memdesc:a634e9cab4969a594206b1a76e87b8ee1 inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">hash functor tuple wrapped for internal use <br/></td></tr>
<tr class="separator:a634e9cab4969a594206b1a76e87b8ee1 inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a109563a562d2cc52f6819b272923dfa7 inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a109563a562d2cc52f6819b272923dfa7"></a>
typedef hash::hash_tuple_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a109563a562d2cc52f6819b272923dfa7">hash_tuple_type</a></td></tr>
<tr class="memdesc:a109563a562d2cc52f6819b272923dfa7 inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of hash tuple. <br/></td></tr>
<tr class="separator:a109563a562d2cc52f6819b272923dfa7 inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09b825ee98486afcfc2ae03f0bef294f inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a09b825ee98486afcfc2ae03f0bef294f"></a>
typedef options::stat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a09b825ee98486afcfc2ae03f0bef294f">stat</a></td></tr>
<tr class="memdesc:a09b825ee98486afcfc2ae03f0bef294f inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal statistics type <br/></td></tr>
<tr class="separator:a09b825ee98486afcfc2ae03f0bef294f inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc46bccdc9a3f704b49d426e4d7183b0 inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abc46bccdc9a3f704b49d426e4d7183b0"></a>
typedef options::mutex_policy&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#abc46bccdc9a3f704b49d426e4d7183b0">original_mutex_policy</a></td></tr>
<tr class="memdesc:abc46bccdc9a3f704b49d426e4d7183b0 inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concurrent access policy, see cuckoo::type_traits::mutex_policy. <br/></td></tr>
<tr class="separator:abc46bccdc9a3f704b49d426e4d7183b0 inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68699b6f6b7957c4f604e4677c9655db inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
original_mutex_policy::template <br class="typebreak"/>
rebind_statistics&lt; typename <br class="typebreak"/>
std::conditional&lt; std::is_same<br class="typebreak"/>
&lt; <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a09b825ee98486afcfc2ae03f0bef294f">stat</a>, <a class="el" href="structcds_1_1intrusive_1_1cuckoo_1_1empty__stat.html">cuckoo::empty_stat</a> &gt;<br class="typebreak"/>
::value, typename <br class="typebreak"/>
original_mutex_policy::empty_stat, <br class="typebreak"/>
typename <br class="typebreak"/>
original_mutex_policy::real_stat &gt;<br class="typebreak"/>
::type &gt;::other&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a68699b6f6b7957c4f604e4677c9655db">mutex_policy</a></td></tr>
<tr class="memdesc:a68699b6f6b7957c4f604e4677c9655db inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Actual mutex policy.  <a href="#a68699b6f6b7957c4f604e4677c9655db">More...</a><br/></td></tr>
<tr class="separator:a68699b6f6b7957c4f604e4677c9655db inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe7f0210fc64d5dcb183719c21551778 inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe7f0210fc64d5dcb183719c21551778"></a>
typedef <br class="typebreak"/>
opt::details::make_equal_to<br class="typebreak"/>
&lt; <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a80f3988a87de588e0a2d873592e6da40">value_type</a>, <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#aec37050e433a8c1d925eda572252fb0d">options</a>,!c_isSorted &gt;<br class="typebreak"/>
::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#afe7f0210fc64d5dcb183719c21551778">key_equal_to</a></td></tr>
<tr class="memdesc:afe7f0210fc64d5dcb183719c21551778 inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key equality functor; used only for unordered probe-set. <br/></td></tr>
<tr class="separator:afe7f0210fc64d5dcb183719c21551778 inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14f042d973da8c6cae20c0cc8cb4d0b9 inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a14f042d973da8c6cae20c0cc8cb4d0b9"></a>
typedef <br class="typebreak"/>
opt::details::make_comparator<br class="typebreak"/>
&lt; <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a80f3988a87de588e0a2d873592e6da40">value_type</a>, <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#aec37050e433a8c1d925eda572252fb0d">options</a> &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a14f042d973da8c6cae20c0cc8cb4d0b9">key_comparator</a></td></tr>
<tr class="memdesc:a14f042d973da8c6cae20c0cc8cb4d0b9 inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">key comparing functor based on opt::compare and opt::less option setter. Used only for ordered probe set <br/></td></tr>
<tr class="separator:a14f042d973da8c6cae20c0cc8cb4d0b9 inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9652debeb26265468867f60adddd6d7 inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab9652debeb26265468867f60adddd6d7"></a>
typedef options::allocator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#ab9652debeb26265468867f60adddd6d7">allocator</a></td></tr>
<tr class="memdesc:ab9652debeb26265468867f60adddd6d7 inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocator type <br/></td></tr>
<tr class="separator:ab9652debeb26265468867f60adddd6d7 inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09d1717e8d2e1b73b08c422c1b79cc65 inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a09d1717e8d2e1b73b08c422c1b79cc65"></a>
typedef options::item_counter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a09d1717e8d2e1b73b08c422c1b79cc65">item_counter</a></td></tr>
<tr class="memdesc:a09d1717e8d2e1b73b08c422c1b79cc65 inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">item counter type <br/></td></tr>
<tr class="separator:a09d1717e8d2e1b73b08c422c1b79cc65 inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad56745d9580594c19b680d8d0e16e48c inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad56745d9580594c19b680d8d0e16e48c"></a>
typedef options::disposer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#ad56745d9580594c19b680d8d0e16e48c">disposer</a></td></tr>
<tr class="memdesc:ad56745d9580594c19b680d8d0e16e48c inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">node disposer <br/></td></tr>
<tr class="separator:ad56745d9580594c19b680d8d0e16e48c inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classcds_1_1intrusive_1_1_cuckoo_set')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html">cds::intrusive::CuckooSet&lt; std::pair&lt; Key const, T &gt;, Traits &gt;</a></td></tr>
<tr class="memitem:a3e221ce6294ce2a9bd4ad4e6fe06b367 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a3e221ce6294ce2a9bd4ad4e6fe06b367">CuckooSet</a> ()</td></tr>
<tr class="memdesc:a3e221ce6294ce2a9bd4ad4e6fe06b367 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#a3e221ce6294ce2a9bd4ad4e6fe06b367">More...</a><br/></td></tr>
<tr class="separator:a3e221ce6294ce2a9bd4ad4e6fe06b367 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac18f71b08de102c3ca85b9bc53963b38 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#ac18f71b08de102c3ca85b9bc53963b38">CuckooSet</a> (size_t nInitialSize, unsigned int nProbesetSize, unsigned int nProbesetThreshold=0)</td></tr>
<tr class="memdesc:ac18f71b08de102c3ca85b9bc53963b38 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the set object with given probe set size and threshold.  <a href="#ac18f71b08de102c3ca85b9bc53963b38">More...</a><br/></td></tr>
<tr class="separator:ac18f71b08de102c3ca85b9bc53963b38 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cec0e76f68e4d0462420d577c728c76 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a2cec0e76f68e4d0462420d577c728c76">CuckooSet</a> (<a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a109563a562d2cc52f6819b272923dfa7">hash_tuple_type</a> const &amp;h)</td></tr>
<tr class="memdesc:a2cec0e76f68e4d0462420d577c728c76 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the set object with given hash functor tuple.  <a href="#a2cec0e76f68e4d0462420d577c728c76">More...</a><br/></td></tr>
<tr class="separator:a2cec0e76f68e4d0462420d577c728c76 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a028ecfbae605b0199e0b0b2d15fd3d73 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a028ecfbae605b0199e0b0b2d15fd3d73">CuckooSet</a> (size_t nInitialSize, unsigned int nProbesetSize, unsigned int nProbesetThreshold, <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a109563a562d2cc52f6819b272923dfa7">hash_tuple_type</a> const &amp;h)</td></tr>
<tr class="memdesc:a028ecfbae605b0199e0b0b2d15fd3d73 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the set object with given probe set properties and hash functor tuple.  <a href="#a028ecfbae605b0199e0b0b2d15fd3d73">More...</a><br/></td></tr>
<tr class="separator:a028ecfbae605b0199e0b0b2d15fd3d73 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95f68f38da3654e56754e08c94f66d2e inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a95f68f38da3654e56754e08c94f66d2e">CuckooSet</a> (<a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a109563a562d2cc52f6819b272923dfa7">hash_tuple_type</a> &amp;&amp;h)</td></tr>
<tr class="memdesc:a95f68f38da3654e56754e08c94f66d2e inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the set object with given hash functor tuple (move semantics)  <a href="#a95f68f38da3654e56754e08c94f66d2e">More...</a><br/></td></tr>
<tr class="separator:a95f68f38da3654e56754e08c94f66d2e inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aede715e446da90de4e51b19d64236da3 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#aede715e446da90de4e51b19d64236da3">CuckooSet</a> (size_t nInitialSize, unsigned int nProbesetSize, unsigned int nProbesetThreshold, <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a109563a562d2cc52f6819b272923dfa7">hash_tuple_type</a> &amp;&amp;h)</td></tr>
<tr class="memdesc:aede715e446da90de4e51b19d64236da3 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the set object with given probe set properties and hash functor tuple (move semantics)  <a href="#aede715e446da90de4e51b19d64236da3">More...</a><br/></td></tr>
<tr class="separator:aede715e446da90de4e51b19d64236da3 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a545595f7caba3bdd3520e16115a7fa2b inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a545595f7caba3bdd3520e16115a7fa2b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a545595f7caba3bdd3520e16115a7fa2b">~CuckooSet</a> ()</td></tr>
<tr class="memdesc:a545595f7caba3bdd3520e16115a7fa2b inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr class="separator:a545595f7caba3bdd3520e16115a7fa2b inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75199d012de6ab7c3315dda78b4b3025 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a75199d012de6ab7c3315dda78b4b3025">insert</a> (<a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a80f3988a87de588e0a2d873592e6da40">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:a75199d012de6ab7c3315dda78b4b3025 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="#a75199d012de6ab7c3315dda78b4b3025">More...</a><br/></td></tr>
<tr class="separator:a75199d012de6ab7c3315dda78b4b3025 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a103ae7f5ebd72ac7fe2a1cc751f937bd inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a103ae7f5ebd72ac7fe2a1cc751f937bd">insert</a> (<a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a80f3988a87de588e0a2d873592e6da40">value_type</a> &amp;val, Func f)</td></tr>
<tr class="memdesc:a103ae7f5ebd72ac7fe2a1cc751f937bd inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="#a103ae7f5ebd72ac7fe2a1cc751f937bd">More...</a><br/></td></tr>
<tr class="separator:a103ae7f5ebd72ac7fe2a1cc751f937bd inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d5878c5b3002bbe258a8936c9327c31 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top">std::pair&lt; bool, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a5d5878c5b3002bbe258a8936c9327c31">ensure</a> (<a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a80f3988a87de588e0a2d873592e6da40">value_type</a> &amp;val, Func func)</td></tr>
<tr class="memdesc:a5d5878c5b3002bbe258a8936c9327c31 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures that the <code>val</code> exists in the set.  <a href="#a5d5878c5b3002bbe258a8936c9327c31">More...</a><br/></td></tr>
<tr class="separator:a5d5878c5b3002bbe258a8936c9327c31 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44c2d0ae24a2a32edc066a96e003e9bb inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a44c2d0ae24a2a32edc066a96e003e9bb">unlink</a> (<a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a80f3988a87de588e0a2d873592e6da40">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:a44c2d0ae24a2a32edc066a96e003e9bb inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlink the item <code>val</code> from the set.  <a href="#a44c2d0ae24a2a32edc066a96e003e9bb">More...</a><br/></td></tr>
<tr class="separator:a44c2d0ae24a2a32edc066a96e003e9bb inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b4514beb5a17fa560faca26c3134e38 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a80f3988a87de588e0a2d873592e6da40">value_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a9b4514beb5a17fa560faca26c3134e38">erase</a> (Q const &amp;val)</td></tr>
<tr class="memdesc:a9b4514beb5a17fa560faca26c3134e38 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set.  <a href="#a9b4514beb5a17fa560faca26c3134e38">More...</a><br/></td></tr>
<tr class="separator:a9b4514beb5a17fa560faca26c3134e38 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7036d8b2985726d5cb138c879d016a44 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a80f3988a87de588e0a2d873592e6da40">value_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a7036d8b2985726d5cb138c879d016a44">erase</a> (Q const &amp;val, Func f)</td></tr>
<tr class="memdesc:a7036d8b2985726d5cb138c879d016a44 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the item from the set.  <a href="#a7036d8b2985726d5cb138c879d016a44">More...</a><br/></td></tr>
<tr class="separator:a7036d8b2985726d5cb138c879d016a44 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a664d70addf3f701f1a62013c69355790 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a80f3988a87de588e0a2d873592e6da40">value_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a664d70addf3f701f1a62013c69355790">erase_with</a> (Q const &amp;val, Predicate pred)</td></tr>
<tr class="memdesc:a664d70addf3f701f1a62013c69355790 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set using <code>pred</code> predicate for searching.  <a href="#a664d70addf3f701f1a62013c69355790">More...</a><br/></td></tr>
<tr class="separator:a664d70addf3f701f1a62013c69355790 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a213ba3e87c26e5a1afcc84e7cea477ad inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a80f3988a87de588e0a2d873592e6da40">value_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a213ba3e87c26e5a1afcc84e7cea477ad">erase_with</a> (Q const &amp;val, Predicate pred, Func f)</td></tr>
<tr class="memdesc:a213ba3e87c26e5a1afcc84e7cea477ad inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set using <code>pred</code> predicate for searching.  <a href="#a213ba3e87c26e5a1afcc84e7cea477ad">More...</a><br/></td></tr>
<tr class="separator:a213ba3e87c26e5a1afcc84e7cea477ad inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a578457cdff461f79ba9e57515d851b71 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a578457cdff461f79ba9e57515d851b71">find</a> (Q &amp;val, Func f)</td></tr>
<tr class="memdesc:a578457cdff461f79ba9e57515d851b71 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the key <code>val</code>.  <a href="#a578457cdff461f79ba9e57515d851b71">More...</a><br/></td></tr>
<tr class="separator:a578457cdff461f79ba9e57515d851b71 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac54aa700ea45175265ad3af45c4b8e35 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#ac54aa700ea45175265ad3af45c4b8e35">find</a> (Q const &amp;val, Func f)</td></tr>
<tr class="memdesc:ac54aa700ea45175265ad3af45c4b8e35 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the key <code>val</code>.  <a href="#ac54aa700ea45175265ad3af45c4b8e35">More...</a><br/></td></tr>
<tr class="separator:ac54aa700ea45175265ad3af45c4b8e35 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6bf37c7669ff2d0cbe34df7f1f4a60d inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#ad6bf37c7669ff2d0cbe34df7f1f4a60d">find</a> (Q const &amp;val)</td></tr>
<tr class="memdesc:ad6bf37c7669ff2d0cbe34df7f1f4a60d inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the key <code>val</code>.  <a href="#ad6bf37c7669ff2d0cbe34df7f1f4a60d">More...</a><br/></td></tr>
<tr class="separator:ad6bf37c7669ff2d0cbe34df7f1f4a60d inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a783b11c482e9e855ec9d207262aefd75 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a783b11c482e9e855ec9d207262aefd75">find_with</a> (Q &amp;val, Predicate pred, Func f)</td></tr>
<tr class="memdesc:a783b11c482e9e855ec9d207262aefd75 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the key <code>val</code> using <code>pred</code> predicate for comparing.  <a href="#a783b11c482e9e855ec9d207262aefd75">More...</a><br/></td></tr>
<tr class="separator:a783b11c482e9e855ec9d207262aefd75 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6571cfd080e66ed860360fe5bad2cd41 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a6571cfd080e66ed860360fe5bad2cd41">find_with</a> (Q const &amp;val, Predicate pred, Func f)</td></tr>
<tr class="memdesc:a6571cfd080e66ed860360fe5bad2cd41 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the key <code>val</code> using <code>pred</code> predicate for comparing.  <a href="#a6571cfd080e66ed860360fe5bad2cd41">More...</a><br/></td></tr>
<tr class="separator:a6571cfd080e66ed860360fe5bad2cd41 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42d5afdd7bc075a28347a43c6ed6a067 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a42d5afdd7bc075a28347a43c6ed6a067">find_with</a> (Q const &amp;val, Predicate pred)</td></tr>
<tr class="memdesc:a42d5afdd7bc075a28347a43c6ed6a067 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the key <code>val</code> using <code>pred</code> predicate for comparing.  <a href="#a42d5afdd7bc075a28347a43c6ed6a067">More...</a><br/></td></tr>
<tr class="separator:a42d5afdd7bc075a28347a43c6ed6a067 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc138e7fd59de4e6a8e0ce6fc13b3f20 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#adc138e7fd59de4e6a8e0ce6fc13b3f20">clear</a> ()</td></tr>
<tr class="memdesc:adc138e7fd59de4e6a8e0ce6fc13b3f20 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the set.  <a href="#adc138e7fd59de4e6a8e0ce6fc13b3f20">More...</a><br/></td></tr>
<tr class="separator:adc138e7fd59de4e6a8e0ce6fc13b3f20 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23148d079b580ccc0a9141094b9534ee inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a23148d079b580ccc0a9141094b9534ee">clear_and_dispose</a> (Disposer oDisposer)</td></tr>
<tr class="memdesc:a23148d079b580ccc0a9141094b9534ee inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the set and calls <code>disposer</code> for each item.  <a href="#a23148d079b580ccc0a9141094b9534ee">More...</a><br/></td></tr>
<tr class="separator:a23148d079b580ccc0a9141094b9534ee inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65734637d991285764dd94c663afab69 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a65734637d991285764dd94c663afab69">empty</a> () const</td></tr>
<tr class="memdesc:a65734637d991285764dd94c663afab69 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the set is empty.  <a href="#a65734637d991285764dd94c663afab69">More...</a><br/></td></tr>
<tr class="separator:a65734637d991285764dd94c663afab69 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad77539c94df2fa452b5d15617c0b3cb2 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad77539c94df2fa452b5d15617c0b3cb2"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#ad77539c94df2fa452b5d15617c0b3cb2">size</a> () const</td></tr>
<tr class="memdesc:ad77539c94df2fa452b5d15617c0b3cb2 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns item count in the set. <br/></td></tr>
<tr class="separator:ad77539c94df2fa452b5d15617c0b3cb2 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ace0cf32a214311fb09204c86b0d2ff inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a9ace0cf32a214311fb09204c86b0d2ff">bucket_count</a> () const</td></tr>
<tr class="memdesc:a9ace0cf32a214311fb09204c86b0d2ff inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of hash table.  <a href="#a9ace0cf32a214311fb09204c86b0d2ff">More...</a><br/></td></tr>
<tr class="separator:a9ace0cf32a214311fb09204c86b0d2ff inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28e8654c925669bf34f15bdb77dec065 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a28e8654c925669bf34f15bdb77dec065"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a28e8654c925669bf34f15bdb77dec065">lock_count</a> () const</td></tr>
<tr class="memdesc:a28e8654c925669bf34f15bdb77dec065 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns lock array size. <br/></td></tr>
<tr class="separator:a28e8654c925669bf34f15bdb77dec065 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bd9a9d0b05db9bbcd090b51e3e866af inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9bd9a9d0b05db9bbcd090b51e3e866af"></a>
<a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a09b825ee98486afcfc2ae03f0bef294f">stat</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a9bd9a9d0b05db9bbcd090b51e3e866af">statistics</a> () const</td></tr>
<tr class="memdesc:a9bd9a9d0b05db9bbcd090b51e3e866af inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const reference to internal statistics. <br/></td></tr>
<tr class="separator:a9bd9a9d0b05db9bbcd090b51e3e866af inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4107eae58541683b5abc0c337d010c9 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af4107eae58541683b5abc0c337d010c9"></a>
mutex_policy::statistics_type <br class="typebreak"/>
const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#af4107eae58541683b5abc0c337d010c9">mutex_policy_statistics</a> () const</td></tr>
<tr class="memdesc:af4107eae58541683b5abc0c337d010c9 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const reference to mutex policy internal statistics. <br/></td></tr>
<tr class="separator:af4107eae58541683b5abc0c337d010c9 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classcds_1_1intrusive_1_1_cuckoo_set')"><img src="closed.png" alt="-"/>&#160;Static Protected Attributes inherited from <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html">cds::intrusive::CuckooSet&lt; std::pair&lt; Key const, T &gt;, Traits &gt;</a></td></tr>
<tr class="memitem:aec91125eaafeba9da642a4ec74fd7c0f inherit pub_static_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec91125eaafeba9da642a4ec74fd7c0f"></a>
static bool const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#aec91125eaafeba9da642a4ec74fd7c0f">c_isSorted</a></td></tr>
<tr class="memdesc:aec91125eaafeba9da642a4ec74fd7c0f inherit pub_static_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether the probe set should be ordered <br/></td></tr>
<tr class="separator:aec91125eaafeba9da642a4ec74fd7c0f inherit pub_static_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af57c3ed1e36757238a5396a667eeb06f inherit pub_static_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af57c3ed1e36757238a5396a667eeb06f"></a>
static size_t const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#af57c3ed1e36757238a5396a667eeb06f">c_nArity</a></td></tr>
<tr class="memdesc:af57c3ed1e36757238a5396a667eeb06f inherit pub_static_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">the arity of cuckoo hashing: the number of hash functors provided; minimum 2. <br/></td></tr>
<tr class="separator:af57c3ed1e36757238a5396a667eeb06f inherit pub_static_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7428e959608e5decac221dc317e8da8 inherit pub_static_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa7428e959608e5decac221dc317e8da8"></a>
static unsigned int const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#aa7428e959608e5decac221dc317e8da8">c_nDefaultProbesetSize</a></td></tr>
<tr class="memdesc:aa7428e959608e5decac221dc317e8da8 inherit pub_static_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">default probeset size <br/></td></tr>
<tr class="separator:aa7428e959608e5decac221dc317e8da8 inherit pub_static_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49f3b066d9b88fd5ec69263a5783ac17 inherit pub_static_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a49f3b066d9b88fd5ec69263a5783ac17"></a>
static size_t const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a49f3b066d9b88fd5ec69263a5783ac17">c_nDefaultInitialSize</a></td></tr>
<tr class="memdesc:a49f3b066d9b88fd5ec69263a5783ac17 inherit pub_static_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">default initial size <br/></td></tr>
<tr class="separator:a49f3b066d9b88fd5ec69263a5783ac17 inherit pub_static_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceb27b2754ff51b10ee5e7754aafec36 inherit pub_static_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aceb27b2754ff51b10ee5e7754aafec36"></a>
static unsigned int const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#aceb27b2754ff51b10ee5e7754aafec36">c_nRelocateLimit</a></td></tr>
<tr class="memdesc:aceb27b2754ff51b10ee5e7754aafec36 inherit pub_static_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count of attempts to relocate before giving up. <br/></td></tr>
<tr class="separator:aceb27b2754ff51b10ee5e7754aafec36 inherit pub_static_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Key, typename T, typename Traits = cuckoo::type_traits&gt;<br/>
class cds::container::CuckooMap&lt; Key, T, Traits &gt;</h3>

<p>Cuckoo hash map. </p>
<p>Source</p>
<ul>
<li>[2007] M.Herlihy, N.Shavit, M.Tzafrir "Concurrent Cuckoo Hashing. Technical report"</li>
<li>[2008] Maurice Herlihy, Nir Shavit "The Art of Multiprocessor Programming"</li>
</ul>
<p><b>About Cuckoo hashing</b></p>
<p>[From "The Art of Multiprocessor Programming"] Cuckoo hashing is a hashing algorithm in which a newly added item displaces any earlier item occupying the same slot. For brevity, a table is a k-entry array of items. For a hash set f size N = 2k we use a two-entry array of tables, and two independent hash functions, <code> h0, h1: KeyRange -&gt; 0,...,k-1</code> mapping the set of possible keys to entries in he array. To test whether a value <code>x</code> is in the set, <code>find(x)</code> tests whether either <code>table[0][h0(x)]</code> or <code>table[1][h1(x)]</code> is equal to <code>x</code>. Similarly, <code>erase(x)</code>checks whether <code>x</code> is in either <code>table[0][h0(x)]</code> or <code>table[1][h1(x)]</code>, ad removes it if found.</p>
<p>The <code>insert(x)</code> successively "kicks out" conflicting items until every key has a slot. To add <code>x</code>, the method swaps <code>x</code> with <code>y</code>, the current occupant of <code>table[0][h0(x)]</code>. If the prior value was <code>NULL</code>, it is done. Otherwise, it swaps the newly nest-less value <code>y</code> for the current occupant of <code>table[1][h1(y)]</code> in the same way. As before, if the prior value was <code>NULL</code>, it is done. Otherwise, the method continues swapping entries (alternating tables) until it finds an empty slot. We might not find an empty slot, either because the table is full, or because the sequence of displacement forms a cycle. We therefore need an upper limit on the number of successive displacements we are willing to undertake. When this limit is exceeded, we resize the hash table, choose new hash functions and start over.</p>
<p>For concurrent cuckoo hashing, rather than organizing the set as a two-dimensional table of items, we use two-dimensional table of probe sets, where a probe set is a constant-sized set of items with the same hash code. Each probe set holds at most <code>PROBE_SIZE</code> items, but the algorithm tries to ensure that when the set is quiescent (i.e no method call in progress) each probe set holds no more than <code>THRESHOLD &lt; PROBE_SET</code> items. While method calls are in-flight, a probe set may temporarily hold more than <code>THRESHOLD</code> but never more than <code>PROBE_SET</code> items.</p>
<p>In current implementation, a probe set can be defined either as a (single-linked) list or as a fixed-sized vector, optionally ordered.</p>
<p>In description above two-table cuckoo hashing (<code>k = 2</code>) has been considered. We can generalize this approach for <code>k &gt;= 2</code> when we have <code>k</code> hash functions <code>h[0], ... h[k-1]</code> and <code>k</code> tables <code>table[0], ... table[k-1]</code>.</p>
<p>The search in probe set is linear, the complexity is <code> O(PROBE_SET) </code>. The probe set may be ordered or not. Ordered probe set can be a little better since the average search complexity is <code>O(PROBE_SET/2)</code>. However, the overhead of sorting can eliminate a gain of ordered search.</p>
<p>The probe set is ordered if <a class="el" href="structcds_1_1opt_1_1compare.html" title="[type-option] Option setter for key comparing">opt::compare</a> or <a class="el" href="structcds_1_1opt_1_1less.html" title="[type-option] Option setter for less predicate">opt::less</a> is specified in <code>CuckooSet</code> declaration. Otherwise, the probe set is unordered and <code>CuckooSet</code> must contain <a class="el" href="structcds_1_1opt_1_1equal__to.html" title="[type-option] Option setter for equal_to predicate">opt::equal_to</a> option.</p>
<p>Template arguments:</p>
<ul>
<li><code>Key</code> - key type</li>
<li><code>T</code> - the type stored in the map.</li>
<li><code>Traits</code> - type traits. See <a class="el" href="structcds_1_1container_1_1cuckoo_1_1type__traits.html" title="Type traits for CuckooSet and CuckooMap classes.">cuckoo::type_traits</a> for explanation. It is possible to declare option-based set with <a class="el" href="structcds_1_1container_1_1cuckoo_1_1make__traits.html" title="Metafunction converting option list to CuckooSet/CuckooMap traits.">cuckoo::make_traits</a> metafunction result as <code>Traits</code> template argument.</li>
</ul>
<p>Template argument list <code>Options</code>... of <a class="el" href="structcds_1_1container_1_1cuckoo_1_1make__traits.html" title="Metafunction converting option list to CuckooSet/CuckooMap traits.">cuckoo::make_traits</a> metafunction are:</p>
<ul>
<li><a class="el" href="structcds_1_1opt_1_1hash.html" title="[type-option] Option setter for a hash function">opt::hash</a> - hash functor tuple, mandatory option. At least, two hash functors should be provided. All hash functor should be orthogonal (different): for each <code> i,j: i != j =&gt; h[i](x) != h[j](x) </code>. The hash functors are passed as <code> std::tuple&lt; H1, H2, ... Hn &gt; </code>. The number of hash functors specifies the number <code>k</code> - the count of hash tables in cuckoo hashing. If the compiler supports variadic templates then k is unlimited, otherwise up to 10 different hash functors are supported.</li>
<li><a class="el" href="structcds_1_1opt_1_1mutex__policy.html" title="[type-option] Concurrent access policy">opt::mutex_policy</a> - concurrent access policy. Available policies: <a class="el" href="classcds_1_1container_1_1cuckoo_1_1striping.html" title="Lock striping concurrent access policy. This is typedef for intrusive::cuckoo::striping template...">cuckoo::striping</a>, <a class="el" href="classcds_1_1container_1_1cuckoo_1_1refinable.html" title="Refinable concurrent access policy. This is typedef for intrusive::cuckoo::refinable template...">cuckoo::refinable</a>. Default is <a class="el" href="classcds_1_1container_1_1cuckoo_1_1striping.html" title="Lock striping concurrent access policy. This is typedef for intrusive::cuckoo::striping template...">cuckoo::striping</a>.</li>
<li><a class="el" href="structcds_1_1opt_1_1equal__to.html" title="[type-option] Option setter for equal_to predicate">opt::equal_to</a> - key equality functor like <code>std::equal_to</code>. If this functor is defined then the probe-set will be unordered. If <a class="el" href="structcds_1_1opt_1_1compare.html" title="[type-option] Option setter for key comparing">opt::compare</a> or <a class="el" href="structcds_1_1opt_1_1less.html" title="[type-option] Option setter for less predicate">opt::less</a> option is specified too, then the probe-set will be ordered and <a class="el" href="structcds_1_1opt_1_1equal__to.html" title="[type-option] Option setter for equal_to predicate">opt::equal_to</a> will be ignored.</li>
<li><a class="el" href="structcds_1_1opt_1_1compare.html" title="[type-option] Option setter for key comparing">opt::compare</a> - key comparison functor. No default functor is provided. If the option is not specified, the <a class="el" href="structcds_1_1opt_1_1less.html" title="[type-option] Option setter for less predicate">opt::less</a> is used. If <a class="el" href="structcds_1_1opt_1_1compare.html" title="[type-option] Option setter for key comparing">opt::compare</a> or <a class="el" href="structcds_1_1opt_1_1less.html" title="[type-option] Option setter for less predicate">opt::less</a> option is specified, then the probe-set will be ordered.</li>
<li><a class="el" href="structcds_1_1opt_1_1less.html" title="[type-option] Option setter for less predicate">opt::less</a> - specifies binary predicate used for key comparision. Default is <code>std::less&lt;T&gt;</code>. If <a class="el" href="structcds_1_1opt_1_1compare.html" title="[type-option] Option setter for key comparing">opt::compare</a> or <a class="el" href="structcds_1_1opt_1_1less.html" title="[type-option] Option setter for less predicate">opt::less</a> option is specified, then the probe-set will be ordered.</li>
<li><a class="el" href="structcds_1_1opt_1_1item__counter.html" title="[type-option] Option setter for item counting">opt::item_counter</a> - the type of item counting feature. Default is <a class="el" href="classcds_1_1opt_1_1v_1_1sequential__item__counter.html">opt::v::sequential_item_counter</a>.</li>
<li><a class="el" href="structcds_1_1opt_1_1allocator.html" title="[type-option] Option setter for an allocator">opt::allocator</a> - the allocator type using for allocating bucket tables. Default is <code>CDS_DEFAULT_ALLOCATOR</code> </li>
<li><a class="el" href="structcds_1_1opt_1_1node__allocator.html" title="[type-option] Option setter for node allocator">opt::node_allocator</a> - the allocator type using for allocating map's items. If this option is not specified then the type defined in <a class="el" href="structcds_1_1opt_1_1allocator.html" title="[type-option] Option setter for an allocator">opt::allocator</a> option is used.</li>
<li><a class="el" href="structcds_1_1container_1_1cuckoo_1_1store__hash.html" title="Option specifying whether to store hash values in the node.">cuckoo::store_hash</a> - this option reserves additional space in the node to store the hash value of the object once it's introduced in the container. When this option is used, the map will store the calculated hash value in the node and rehashing operations won't need to recalculate the hash of the value. This option will improve the performance of maps when rehashing is frequent or hashing the value is a slow operation. Default value is <code>false</code>.</li>
<li><a class="el" href="structcds_1_1intrusive_1_1cuckoo_1_1probeset__type.html">cuckoo::probeset_type</a> - type of probe set, may be <code>cuckoo::list</code> or <code>cuckoo::vector&lt;Capacity&gt;</code>, Default is <code>cuckoo::list</code>.</li>
<li><a class="el" href="structcds_1_1opt_1_1stat.html" title="[type-option] Generic option setter for statisitcs">opt::stat</a> - internal statistics. Possibly types: <a class="el" href="classcds_1_1container_1_1cuckoo_1_1stat.html" title="Cuckoo statistics. This is typedef for intrusive::cuckoo::stat.">cuckoo::stat</a>, <a class="el" href="classcds_1_1container_1_1cuckoo_1_1empty__stat.html" title="Cuckoo empty statistics.This is typedef for intrusive::cuckoo::empty_stat.">cuckoo::empty_stat</a>. Default is <a class="el" href="classcds_1_1container_1_1cuckoo_1_1empty__stat.html" title="Cuckoo empty statistics.This is typedef for intrusive::cuckoo::empty_stat.">cuckoo::empty_stat</a></li>
</ul>
<p><b>Examples</b></p>
<p>Declares cuckoo mapping from <code>std::string</code> to struct <code>foo</code>. For cuckoo hashing we should provide at least two hash functions: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>hash1 {</div>
<div class="line">    <span class="keywordtype">size_t</span> operator()(std::string <span class="keyword">const</span>&amp; s)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="keywordflow">return</span> cds::opt::v::hash&lt;std::string&gt;( s ) ;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>hash2: <span class="keyword">private</span> hash1 {</div>
<div class="line">    <span class="keywordtype">size_t</span> operator()(std::string <span class="keyword">const</span>&amp; s)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="keywordtype">size_t</span> h = ~( hash1::operator()(s))        ;</div>
<div class="line">        <span class="keywordflow">return</span> ~h + 0x9e3779b9 + (h &lt;&lt; 6) + (h &gt;&gt; 2)    ;</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p>Cuckoo-map with list-based unordered probe set and storing hash values </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cds/container/cuckoo_map.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Declare type traits</span></div>
<div class="line"><span class="keyword">struct </span>my_traits: <span class="keyword">public</span> <a class="code" href="structcds_1_1container_1_1cuckoo_1_1type__traits.html" title="Type traits for CuckooSet and CuckooMap classes.">cds::container::cuckoo::type_traits</a></div>
<div class="line">{</div>
<div class="line">    <span class="keyword">typedef</span> std::equal_to&lt; std::string &gt; equal_to ;</div>
<div class="line">    <span class="keyword">typedef</span> std::tuple&lt; hash1, hash2 &gt;  <a class="code" href="classcds_1_1container_1_1_cuckoo_map.html#a8a8e673f70c3333a37496b531f3402a5" title="hash functor tuple wrapped for internal use">hash</a> ;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">bool</span> <span class="keyword">const</span> store_hash = true ;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Declare CuckooMap type</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1container_1_1_cuckoo_map.html" title="Cuckoo hash map.">cds::container::CuckooMap&lt; std::string, foo, my_traits &gt;</a> my_cuckoo_map ;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Equal option-based declaration</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1container_1_1_cuckoo_map.html" title="Cuckoo hash map.">cds::container::CuckooMap</a>&lt; std::string, foo,</div>
<div class="line">    <a class="code" href="structcds_1_1container_1_1cuckoo_1_1make__traits.html" title="Metafunction converting option list to CuckooSet/CuckooMap traits.">cds::container::cuckoo::make_traits</a>&lt;</div>
<div class="line">        <a class="code" href="structcds_1_1opt_1_1hash.html" title="[type-option] Option setter for a hash function">cds::opt::hash&lt; std::tuple&lt; hash1, hash2 &gt;</a> &gt;</div>
<div class="line">        ,<a class="code" href="structcds_1_1opt_1_1equal__to.html" title="[type-option] Option setter for equal_to predicate">cds::opt::equal_to&lt; std::equal_to&lt; std::string &gt;</a> &gt;</div>
<div class="line">        ,<a class="code" href="structcds_1_1container_1_1cuckoo_1_1store__hash.html" title="Option specifying whether to store hash values in the node.">cds::container::cuckoo::store_hash&lt; true &gt;</a></div>
<div class="line">    &gt;::type</div>
<div class="line">&gt; opt_cuckoo_map ;</div>
</div><!-- fragment --><p>If we provide <code>less</code> functor instead of <code>equal_to</code> we get as a result a cuckoo map with ordered probe set that may improve performance. Example for ordered vector-based probe-set:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cds/container/cuckoo_map.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Declare type traits</span></div>
<div class="line"><span class="comment">// We use a vector of capacity 4 as probe-set container and store hash values in the node</span></div>
<div class="line"><span class="keyword">struct </span>my_traits: <span class="keyword">public</span> <a class="code" href="structcds_1_1container_1_1cuckoo_1_1type__traits.html" title="Type traits for CuckooSet and CuckooMap classes.">cds::container::cuckoo::type_traits</a></div>
<div class="line">{</div>
<div class="line">    <span class="keyword">typedef</span> std::less&lt; std::string &gt; less ;</div>
<div class="line">    <span class="keyword">typedef</span> std::tuple&lt; hash1, hash2 &gt;  <a class="code" href="classcds_1_1container_1_1_cuckoo_map.html#a8a8e673f70c3333a37496b531f3402a5" title="hash functor tuple wrapped for internal use">hash</a> ;</div>
<div class="line">    <span class="keyword">typedef</span> cds::container::cuckoo::vector&lt;4&gt; probeset_type ;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">bool</span> <span class="keyword">const</span> store_hash = true ;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Declare CuckooMap type</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1container_1_1_cuckoo_map.html" title="Cuckoo hash map.">cds::container::CuckooMap&lt; std::string, foo, my_traits &gt;</a> my_cuckoo_map ;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Equal option-based declaration</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1container_1_1_cuckoo_map.html" title="Cuckoo hash map.">cds::container::CuckooMap</a>&lt; std::string, foo,</div>
<div class="line">    <a class="code" href="structcds_1_1container_1_1cuckoo_1_1make__traits.html" title="Metafunction converting option list to CuckooSet/CuckooMap traits.">cds::container::cuckoo::make_traits</a>&lt;</div>
<div class="line">        <a class="code" href="structcds_1_1opt_1_1hash.html" title="[type-option] Option setter for a hash function">cds::opt::hash&lt; std::tuple&lt; hash1, hash2 &gt;</a> &gt;</div>
<div class="line">        ,<a class="code" href="structcds_1_1opt_1_1less.html" title="[type-option] Option setter for less predicate">cds::opt::less&lt; std::less&lt; std::string &gt;</a> &gt;</div>
<div class="line">        ,<a class="code" href="structcds_1_1container_1_1cuckoo_1_1probeset__type.html" title="Probe set type option.">cds::container::cuckoo::probeset_type&lt; cds::container::cuckoo::vector&lt;4&gt;</a> &gt;</div>
<div class="line">        ,<a class="code" href="structcds_1_1container_1_1cuckoo_1_1store__hash.html" title="Option specifying whether to store hash values in the node.">cds::container::cuckoo::store_hash&lt; true &gt;</a></div>
<div class="line">    &gt;::type</div>
<div class="line">&gt; opt_cuckoo_map ;</div>
</div><!-- fragment --> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a341c7da08ef0c77406969e8414e71b9d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Traits  = cuckoo::type_traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html">cds::container::CuckooMap</a>&lt; Key, T, Traits &gt;::<a class="el" href="classcds_1_1container_1_1_cuckoo_map.html">CuckooMap</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>Initial size = <a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a92aad97a2dd8a8cc65dd6015e95512b3">c_nDefaultInitialSize</a></p>
<p>Probe set size:</p>
<ul>
<li><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a3f7cdc6c06a45355e7616eacd12a361b">c_nDefaultProbesetSize</a> if <code>probeset_type</code> is <code>cuckoo::list</code> </li>
<li><code>Capacity</code> if <code>probeset_type</code> is <code> cuckoo::vector&lt;Capacity&gt; </code></li>
</ul>
<p>Probe set threshold = probe set size - 1 </p>

</div>
</div>
<a class="anchor" id="a9004754391ab93c87e581461b63fbb44"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Traits  = cuckoo::type_traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html">cds::container::CuckooMap</a>&lt; Key, T, Traits &gt;::<a class="el" href="classcds_1_1container_1_1_cuckoo_map.html">CuckooMap</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nInitialSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nProbesetSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nProbesetThreshold</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an object with given probe set size and threshold. </p>
<p>If probe set type is <code> cuckoo::vector&lt;Capacity&gt; </code> vector then <code>nProbesetSize</code> should be equal to vector's <code>Capacity</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nInitialSize</td><td>Initial map size; if 0 - use default initial size <a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a92aad97a2dd8a8cc65dd6015e95512b3">c_nDefaultInitialSize</a> </td></tr>
    <tr><td class="paramname">nProbesetSize</td><td>probe set size </td></tr>
    <tr><td class="paramname">nProbesetThreshold</td><td>probe set threshold, <code>nProbesetThreshold &lt; nProbesetSize</code>. If 0, nProbesetThreshold = nProbesetSize - 1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a779df6d9d36dc26634173734b851d277"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Traits  = cuckoo::type_traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html">cds::container::CuckooMap</a>&lt; Key, T, Traits &gt;::<a class="el" href="classcds_1_1container_1_1_cuckoo_map.html">CuckooMap</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a875c8c5ecc6c99c802d7368b76cd1486">hash_tuple_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an object with given hash functor tuple. </p>
<p>The probe set size and threshold are set as default, see <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a3e221ce6294ce2a9bd4ad4e6fe06b367" title="Default constructor.">CuckooSet()</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>hash functor tuple of type <code>std::tuple&lt;H1, H2, ... Hn&gt;</code> where <code> n == <a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a35537f20a82788a4fa973c9f894ba74c">c_nArity</a> </code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac976f4836e512daeabfff6683f43d323"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Traits  = cuckoo::type_traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html">cds::container::CuckooMap</a>&lt; Key, T, Traits &gt;::<a class="el" href="classcds_1_1container_1_1_cuckoo_map.html">CuckooMap</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nInitialSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nProbesetSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nProbesetThreshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a875c8c5ecc6c99c802d7368b76cd1486">hash_tuple_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a map with given probe set properties and hash functor tuple. </p>
<p>If probe set type is <code> cuckoo::vector&lt;Capacity&gt; </code> vector then <code>nProbesetSize</code> should be equal to vector's <code>Capacity</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nInitialSize</td><td>Initial map size; if 0 - use default initial size <a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a92aad97a2dd8a8cc65dd6015e95512b3">c_nDefaultInitialSize</a> </td></tr>
    <tr><td class="paramname">nProbesetSize</td><td>probe set size </td></tr>
    <tr><td class="paramname">nProbesetThreshold</td><td>probe set threshold, <code>nProbesetThreshold &lt; nProbesetSize</code>. If 0, nProbesetThreshold = nProbesetSize - 1 </td></tr>
    <tr><td class="paramname">h</td><td>hash functor tuple of type <code>std::tuple&lt;H1, H2, ... Hn&gt;</code> where <code> n == <a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a35537f20a82788a4fa973c9f894ba74c">c_nArity</a> </code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a16fd32ddba075fca3ffe33c44181fdb6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Traits  = cuckoo::type_traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html">cds::container::CuckooMap</a>&lt; Key, T, Traits &gt;::<a class="el" href="classcds_1_1container_1_1_cuckoo_map.html">CuckooMap</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a875c8c5ecc6c99c802d7368b76cd1486">hash_tuple_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a map with given hash functor tuple (move semantics) </p>
<p>The probe set size and threshold are set as default, see <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a3e221ce6294ce2a9bd4ad4e6fe06b367" title="Default constructor.">CuckooSet()</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>hash functor tuple of type <code>std::tuple&lt;H1, H2, ... Hn&gt;</code> where <code> n == <a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a35537f20a82788a4fa973c9f894ba74c">c_nArity</a> </code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9bf609fe428c69dd4f794a7936bb6428"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Traits  = cuckoo::type_traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html">cds::container::CuckooMap</a>&lt; Key, T, Traits &gt;::<a class="el" href="classcds_1_1container_1_1_cuckoo_map.html">CuckooMap</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nInitialSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nProbesetSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nProbesetThreshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a875c8c5ecc6c99c802d7368b76cd1486">hash_tuple_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a map with given probe set properties and hash functor tuple (move semantics) </p>
<p>If probe set type is <code> cuckoo::vector&lt;Capacity&gt; </code> vector then <code>nProbesetSize</code> should be equal to vector's <code>Capacity</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nInitialSize</td><td>Initial map size; if 0 - use default initial size <a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a92aad97a2dd8a8cc65dd6015e95512b3">c_nDefaultInitialSize</a> </td></tr>
    <tr><td class="paramname">nProbesetSize</td><td>probe set size </td></tr>
    <tr><td class="paramname">nProbesetThreshold</td><td>probe set threshold, <code>nProbesetThreshold &lt; nProbesetSize</code>. If 0, nProbesetThreshold = nProbesetSize - 1 </td></tr>
    <tr><td class="paramname">h</td><td>hash functor tuple of type <code>std::tuple&lt;H1, H2, ... Hn&gt;</code> where <code> n == <a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a35537f20a82788a4fa973c9f894ba74c">c_nArity</a> </code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a53711b0378aab7e54012f772657c8637"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Traits  = cuckoo::type_traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classcds_1_1container_1_1_cuckoo_map.html">cds::container::CuckooMap</a>&lt; Key, T, Traits &gt;::bucket_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size of hash table. </p>
<p>The hash table size is non-constant and can be increased via resizing. </p>

</div>
</div>
<a class="anchor" id="ae7b5dac039c3782313e7491e84679f8e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Traits  = cuckoo::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_cuckoo_map.html">cds::container::CuckooMap</a>&lt; Key, T, Traits &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For key <code>key</code> inserts data of type <a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a6b7029bea19087f7565784426abffcba">value_type</a> constructed with <code>std::forward&lt;Args&gt;(args)...</code> </p>
<p>Returns <code>true</code> if inserting successful, <code>false</code> otherwise.</p>
<p>This function is available only for compiler that supports variadic template and move semantics </p>

</div>
</div>
<a class="anchor" id="a13dd080b264b73565911c99c760116c2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Traits  = cuckoo::type_traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_cuckoo_map.html">cds::container::CuckooMap</a>&lt; Key, T, Traits &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the map is empty. </p>
<p>Emptiness is checked by item counting: if item count is zero then the map is empty. </p>

</div>
</div>
<a class="anchor" id="a1c858c39f5a5fd11a00a56da4226b303"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Traits  = cuckoo::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;bool, bool&gt; <a class="el" href="classcds_1_1container_1_1_cuckoo_map.html">cds::container::CuckooMap</a>&lt; Key, T, Traits &gt;::ensure </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ensures that the <code>key</code> exists in the map. </p>
<p>The operation performs inserting or changing data with lock-free manner.</p>
<p>If the <code>key</code> not found in the map, then the new item created from <code>key</code> is inserted into the map (note that in this case the <a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a3da032600868e73a64b352ee8fde1ad2">key_type</a> should be constructible from type <code>K</code>). Otherwise, the functor <code>func</code> is called with item found. The functor <code>Func</code> may be a function with signature: </p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> func( <span class="keywordtype">bool</span> bNew, <a class="code" href="classcds_1_1container_1_1_cuckoo_map.html#a6b7029bea19087f7565784426abffcba" title="Key-value pair type stored in the map.">value_type</a>&amp; item ) ;</div>
</div><!-- fragment --><p> or a functor: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>my_functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( <span class="keywordtype">bool</span> bNew, <a class="code" href="classcds_1_1container_1_1_cuckoo_map.html#a6b7029bea19087f7565784426abffcba" title="Key-value pair type stored in the map.">value_type</a>&amp; item ) ;</div>
<div class="line">};</div>
</div><!-- fragment --><p>with arguments:</p>
<ul>
<li><code>bNew</code> - <code>true</code> if the item has been inserted, <code>false</code> otherwise</li>
<li><code>item</code> - item of the list</li>
</ul>
<p>The functor may change any fields of the <code>item.second</code> that is <a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a6b7029bea19087f7565784426abffcba">value_type</a>.</p>
<p>You may pass <code>func</code> argument by reference using <code>boost::ref</code>.</p>
<p>Returns <code> std::pair&lt;bool, bool&gt; </code> where <code>first</code> is true if operation is successfull, <code>second</code> is true if new item has been added or <code>false</code> if the item with <code>key</code> already is in the list. </p>

</div>
</div>
<a class="anchor" id="a949108e97bfa54780ef4816ba0db2ef0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Traits  = cuckoo::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_cuckoo_map.html">cds::container::CuckooMap</a>&lt; Key, T, Traits &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete <code>key</code> from the map. </p>
<p><a class="anchor" id="cds_nonintrusive_CuckooMap_erase_val"></a> Return <code>true</code> if <code>key</code> is found and deleted, <code>false</code> otherwise </p>

</div>
</div>
<a class="anchor" id="aadddd9a1a41b940289a1f7efdf78fcae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Traits  = cuckoo::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_cuckoo_map.html">cds::container::CuckooMap</a>&lt; Key, T, Traits &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete <code>key</code> from the map. </p>
<p><a class="anchor" id="cds_nonintrusive_CuckooMap_erase_func"></a> The function searches an item with key <code>key</code>, calls <code>f</code> functor and deletes the item. If <code>key</code> is not found, the functor is not called.</p>
<p>The functor <code>Func</code> interface: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>extractor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()(<a class="code" href="classcds_1_1container_1_1_cuckoo_map.html#a6b7029bea19087f7565784426abffcba" title="Key-value pair type stored in the map.">value_type</a>&amp; item) { ... }</div>
<div class="line">};</div>
</div><!-- fragment --><p> The functor may be passed by reference using <code>boost:ref</code></p>
<p>Return <code>true</code> if key is found and deleted, <code>false</code> otherwise</p>
<p>See also: <a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a949108e97bfa54780ef4816ba0db2ef0">erase</a> </p>

</div>
</div>
<a class="anchor" id="a773b90f2861fd07a205b1d7113a2faee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Traits  = cuckoo::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_cuckoo_map.html">cds::container::CuckooMap</a>&lt; Key, T, Traits &gt;::erase_with </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the item from the list using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#cds_nonintrusive_CuckooMap_erase_val">erase(Q const&amp;)</a> but <code>pred</code> is used for key comparing. If cuckoo set is ordered, then <code>Predicate</code> should have the interface and semantics like <code>std::less</code>. If cuckoo set is unordered, then <code>Predicate</code> should have the interface and semantics like <code>std::equal_to</code>. <code>Predicate</code> must imply the same element order as the comparator used for building the set. </p>

</div>
</div>
<a class="anchor" id="a89acd3bfb03ea7705a91f05af79e0be9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Traits  = cuckoo::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Predicate , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_cuckoo_map.html">cds::container::CuckooMap</a>&lt; Key, T, Traits &gt;::erase_with </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the item from the list using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#cds_nonintrusive_CuckooMap_erase_func">erase(Q const&amp;, Func)</a> but <code>pred</code> is used for key comparing. If cuckoo set is ordered, then <code>Predicate</code> should have the interface and semantics like <code>std::less</code>. If cuckoo set is unordered, then <code>Predicate</code> should have the interface and semantics like <code>std::equal_to</code>. <code>Predicate</code> must imply the same element order as the comparator used for building the set. </p>

</div>
</div>
<a class="anchor" id="a49e55b628a859e446f9751046c8fa464"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Traits  = cuckoo::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_cuckoo_map.html">cds::container::CuckooMap</a>&lt; Key, T, Traits &gt;::find </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the key <code>key</code>. </p>
<p><a class="anchor" id="cds_nonintrusive_CuckooMap_find_func"></a> The function searches the item with key equal to <code>key</code> and calls the functor <code>f</code> for item found. The interface of <code>Func</code> functor is: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( <a class="code" href="classcds_1_1container_1_1_cuckoo_map.html#a6b7029bea19087f7565784426abffcba" title="Key-value pair type stored in the map.">value_type</a>&amp; item ) ;</div>
<div class="line">};</div>
</div><!-- fragment --><p> where <code>item</code> is the item found.</p>
<p>You can pass <code>f</code> argument by reference using <code>boost::ref</code> or cds::ref.</p>
<p>The functor may change <code>item.second</code>.</p>
<p>The function returns <code>true</code> if <code>key</code> is found, <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="ae563694c48009a3a821c2d1b0740505d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Traits  = cuckoo::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_cuckoo_map.html">cds::container::CuckooMap</a>&lt; Key, T, Traits &gt;::find </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the key <code>key</code>. </p>
<p><a class="anchor" id="cds_nonintrusive_CuckooSet_find_val"></a> The function searches the item with key equal to <code>key</code> and returns <code>true</code> if it is found, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="ac0944519780b201d3f0e265f73e47771"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Traits  = cuckoo::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Predicate , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_cuckoo_map.html">cds::container::CuckooMap</a>&lt; Key, T, Traits &gt;::find_with </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the key <code>val</code> using <code>pred</code> predicate for comparing. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#cds_nonintrusive_CuckooMap_find_func">find(K const&amp;, Func)</a> but <code>pred</code> is used for key comparison. If you use ordered cuckoo set, then <code>Predicate</code> should have the interface and semantics like <code>std::less</code>. If you use unordered cuckoo set, then <code>Predicate</code> should have the interface and semantics like <code>std::equal_to</code>. <code>pred</code> must imply the same element order as the comparator used for building the set. </p>

</div>
</div>
<a class="anchor" id="a4fdacec37e7b9f23998123ee902194a2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Traits  = cuckoo::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_cuckoo_map.html">cds::container::CuckooMap</a>&lt; Key, T, Traits &gt;::find_with </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the key <code>val</code> using <code>pred</code> predicate for comparing. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#cds_nonintrusive_CuckooSet_find_val">find(K const&amp;)</a> but <code>pred</code> is used for key comparison. If you use ordered cuckoo set, then <code>Predicate</code> should have the interface and semantics like <code>std::less</code>. If you use unordered cuckoo set, then <code>Predicate</code> should have the interface and semantics like <code>std::equal_to</code>. <code>pred</code> must imply the same element order as the comparator used for building the set. </p>

</div>
</div>
<a class="anchor" id="a305d109764c5685e2f8d649c15f0ebc7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Traits  = cuckoo::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_cuckoo_map.html">cds::container::CuckooMap</a>&lt; Key, T, Traits &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node with key and default value. </p>
<p>The function creates a node with <code>key</code> and default value, and then inserts the node created into the map.</p>
<p>Preconditions:</p>
<ul>
<li>The <a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a3da032600868e73a64b352ee8fde1ad2">key_type</a> should be constructible from a value of type <code>K</code>. In trivial case, <code>K</code> is equal to <a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a3da032600868e73a64b352ee8fde1ad2">key_type</a>.</li>
<li>The <a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#ab64c43804999ac92124b547ee9d35721">mapped_type</a> should be default-constructible.</li>
</ul>
<p>Returns <code>true</code> if inserting successful, <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="ac30d8a9a5bff3cf218c0f55809bc12bf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Traits  = cuckoo::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_cuckoo_map.html">cds::container::CuckooMap</a>&lt; Key, T, Traits &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V const &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node. </p>
<p>The function creates a node with copy of <code>val</code> value and then inserts the node created into the map.</p>
<p>Preconditions:</p>
<ul>
<li>The <a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a3da032600868e73a64b352ee8fde1ad2">key_type</a> should be constructible from <code>key</code> of type <code>K</code>.</li>
<li>The <a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a6b7029bea19087f7565784426abffcba">value_type</a> should be constructible from <code>val</code> of type <code>V</code>.</li>
</ul>
<p>Returns <code>true</code> if <code>val</code> is inserted into the set, <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="ace105631ebfba013e761db058a96648a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Traits  = cuckoo::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_cuckoo_map.html">cds::container::CuckooMap</a>&lt; Key, T, Traits &gt;::insert_key </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node and initialize it by a functor. </p>
<p>This function inserts new node with key <code>key</code> and if inserting is successful then it calls <code>func</code> functor with signature </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( <a class="code" href="classcds_1_1container_1_1_cuckoo_map.html#a6b7029bea19087f7565784426abffcba" title="Key-value pair type stored in the map.">value_type</a>&amp; item )  ;</div>
<div class="line">};</div>
</div><!-- fragment --><p>The argument <code>item</code> of user-defined functor <code>func</code> is the reference to the map's item inserted:</p>
<ul>
<li><code>item.first</code> is a const reference to item's key that cannot be changed.</li>
<li><code>item.second</code> is a reference to item's value that may be changed.</li>
</ul>
<p>The user-defined functor can be passed by reference using <code>boost::ref</code> and it is called only if inserting is successful.</p>
<p>The key_type should be constructible from value of type <code>K</code>.</p>
<p>The function allows to split creating of new item into two part:</p>
<ul>
<li>create item from <code>key</code>;</li>
<li>insert new item into the map;</li>
<li>if inserting is successful, initialize the value of item by calling <code>func</code> functor</li>
</ul>
<p>This can be useful if complete initialization of object of <code>value_type</code> is heavyweight and it is preferable that the initialization should be completed only if inserting is successful. </p>

</div>
</div>
<a class="anchor" id="a7f84095546cb5c807d5927286933a408"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Traits  = cuckoo::type_traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classcds_1_1container_1_1_cuckoo_map.html">cds::container::CuckooMap</a>&lt; Key, T, Traits &gt;::lock_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns lock array size. </p>
<p>The lock array size is constant. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>cds/container/cuckoo_map.h</li>
</ul>
</div><!-- contents -->
		<hr/>
		<div align="right">
			<b>cds</b> <b>1.4.0</b> 
			Developed by <i>Maxim Khiszinsky aka khizmax</i> 2007 - 2012
			<br/>
			<i>Autogenerated Mon May 20 2013 00:37:55 by Doxygen 1.8.3.1</i>
		</div>
	</BODY>
</HTML>
